---
title: "Exploring local carbon tax models"
subtitle: "Southampton as a case study"
author: 'Ben Anderson (b.anderson@soton.ac.uk) & Tom Rushby'
date: 'Last run at: `r Sys.time()`'
output:
  bookdown::html_document2:
    self_contained: no
    fig_caption: yes
    code_folding: hide
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: TRUE
  bookdown::word_document2:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 2
    fig_width: 5
  bookdown::pdf_document2:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 2
bibliography: '`r path.expand("~/bibliography.bib")`'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```


```{r rmdSetup, include=FALSE}

# Libraries ----
library(dkUtils) # see https://github.com/dataknut/dkUtils
myLibs <- c("tidyverse", # load first so that data.table masks (we only use tidyverse in one context - to filter sf)
            "data.table",
          "flextable",
          "ggplot2",
          "here",
          "leaflet",
          "skimr",
          "sf",
          "viridisLite")

dkUtils::loadLibraries(myLibs)

# Parameters ----

rmdParams <- list()

# Functions ----

source(here::here("R", "functions.R"))

# Others

data <- list() # for holding data

boundaries <- list() # for holding boundaries

```

\newpage

# Introduction

Taxes are not just a way to generate revenue, they are also a means to incentivise 'good' things and dis-incentivise 'bad' things. Think tobacco & alcohol duty, sugar taxes, vehicle emissions and so on. Local taxes on the other hand do not seem to follow the same approach. The [Council Tax](https://www.local.gov.uk/topics/finance-and-business-rates/local-taxation-council-tax-and-business-rates), of which local authorities keep 100%, doesn't really incentivise anything at all as it's based on a notional dwelling value. The same is true of business rates, based on the rental value of the property, of which local authorities keep 50% with some discussion of [making this 100%](https://www.local.gov.uk/topics/finance-and-business-rates/business-rates-retention) in future.

Interestingly council tax rates are set by local authorities within a 'referendable' threshold. A rise above that threshold triggers a local referendum. We return to this later.

In the current 'climate emergency' both central and local governments are considering ways to force greenhouse gas emissions reductions through increased energy efficiency standards for new-builds and large scale investment in energy efficiency and low carbon heating retrofit. Some of this discussion has also focused on lobbying [to remove the VAT due on retrofit](https://www.architectsjournal.co.uk/news/vat-chance-can-tax-reforms-spur-a-retrofit-renaissance) work on the basis that the exisiting approach can incentivise complete reconstruction, with increased embodied carbon emissions, rather than retrofit which generally (?) has less.

In this paper we explore an extension of this concept by using the local tax system to incentivise dwelling owners to reduce their local tax charge by tying a new `local carbon tax` rate to the emissions 'band' of the dwelling. In this model the higher the emissions attributable to the dwelling, the higher the local carbon tax levied.

Clearly such an approach _could_ simply replace the council tax and possibly also the business rates although we focus here on residential dwellings alone. However this would cause a significant inequity for tenants who [currently pay council tax](https://www.gov.uk/council-tax/who-has-to-pay), would be  unable to make energy efficiency or low carbon energy investments in their home but would still have to pay whatever local carbon tax rate applied to the dwelling. We therefore propose two forms of local carbon tax, one that focuses on incentivising low carbon building structures and one which focuses on reducing emissiomns caused by the behaviour of the occupant themselves. Both will act to reduce emissions. We do this by:

 * a `local dwelling fabric carbon tax` - paid by building (dwelling) owners based on some proxy for (or an actual calculation of) the total GHG emissions due to space heating;
 * a `local consumption carbon tax` - paid by occupants based on an some proxyfor (or actual calculation of) the emissions due to total energy consumption less those that 'should' be due to space heating. Obviously if an occupant over-heats the dwelling, they will then be paying more tax... and vice versa (yes?).

This is an attmept to seperate the 'responsibility' of the dwelling owner for increasing the energy efficiency and reducing the emissions due to the building fabric from the responsibility of the 'occupant' for the _as lived_ emissions. In many cases these will be the same individual(s) but not in the case of tenants. It is regularly observed that dwellings built or retrofitted to apparently high energy efficienct standards show a performance gap when actually occupied largely due to occupant energy using and especially ventilation practices. The idea is to seperate these processes and use the parallel local carbon tax system to incentivise lower emissions from both.

Of course we need to be careful. A goal of reducing dwelling fabric emissions could be met by switching to all-electric heating and buying electricity from a purely renewable retailer. You can then use as much energy as you can afford - there will be no additional fabric-based _or_ occupant-based tax to pay. In this sense this could be an entirely avoidable tax. But maybe that is what we want... provided the grid can handle it.

Naturally in the long run such a system is unsustainable. Just as vehicle excise linked to engine emissions will generate less and less revenue over time as engines become cleaner and cleaner, so we would hope that our local carbon taxes would also tend to zero. In this case local authorities would need to evolve the system in such a way as to preserve revenue while still maintaining downward pressure on dwelling based emissions. They could return to some other form of progressive local income tax for example.

In the remainder of this paper we explore a number of ways of calculating both tax rates under a range of scenarios. These are:

 * revenue neutral - it generates the same revenue as the council tax did but puts downward pressure on emissons
 * revenue positive - it generates more revenue than the council tax did so that the 'surplus' can be recycled into energy efficiency and/or low emissions heat interventions while also putting downward pressure on emissons

An over-riding principle is that those at the lower end of the income distribution should be _no worse_ off and preferably better off than they were under the council tax. This may be tricky to model given the council tax rebate system. However, since energy consumption as a percentage of total expenditure declines with income (poor people pay proportionally more) but absolute energy consumption and emissions increase with income, there is clear scope to use tax revenues collected from 'high' emitters to support low income emissions transitions. 

We could assume that higher income higher emitters would have the capital to address their emissions but this may not be the case. They may also have sufficient income not to have to care about 'paying' for their emissions. The fact that the carbon tax rate is not entirely correlated with ability to pay at an individual level (inefficient homes running on fossil fuels are not only the preserve of the very rich) means there may be little incentive for very high income households to change. In this case we may need an additional approach such as a 'stamp duty' * emissions multiplier that is paid on the purchase of properties worth over a certain threshold. This would act to penalise those who had not bothered to invest since their purchasor would drive the price down (they would be about to take a tax hit). Clearly a very expensive house which has zero emissions (as above) would attract a zero tax charge. It might even significantly drive down the value of high emissions properties. Again, this may be what we want but if so it would significantly impact the asset values of people in larger, older and higher emissions homes - some of whom are not well off.

Finally, making the tax charge a dwelling and household level charge means that there is an incentive to increase occupant density since the cost is shared. We know that economies of scale are substantial for energy - the amount of energy used does not increase linearly with occupancy. Reducing single occupancy and incentivising multi-occupancy homes therefore decreases per capita emissions and also decreases total emissions. This could be a potential positive spill-over effect of the system we propose and _might_ align with the Governments proposed changes to the permitted development rights provided they are used to increase occupancy and not just increase unoccupied but heated space!

>NB: on vs off gas implications? Off gas = rural so usually oil. What about wood?

# Modelling the tax

In order to explore the revenue and tax load implications of these ideas we ideally need a dataset which links:

 * current council tax paid
 * estimated or actual annual space heating energy input, cost and emissions. Issues: identifying actual emissons from electricity depends on retailer & tariff; same for gas (e.g. green gas/biomethane offerings)
 * estimated or actual annual non-space heating energy input, cost and emissions. Issues: as above?
 * household income
 * household demographics (as the council tax rebate of 25% appiles to single adult households)
 * benefits status (?)

for each dwelling in all local authorities. We could then calculate the council and carbon tax charges per dwelling and see what happens under our different scenarios.

Unfortunately no such dataset exists.

However there are a number of ways of getting close:

 * EPC data: provides an estimate of kWh/m2 (a measure of energy input) and CO2e as a basis for the EPC banding. We could use the kWh/m2 value but this reduce the charge for large houses with big emissions simply due to size. We do not want that since it is the absolute value of emissions that really matters here. So we would use the kWh value instead. There are [a number of reasons](https://www.passivhaustrust.org.uk/guidance_detail.php?gId=44) why we would _not_ want to use the CO2e or EPC banding as the basis for our calculation, not least that it assumes a fixed and outdated carbon intensity for electricity. Unfortunately EPC data does not tell us about actual occupant-driven energy consumption. This would have to be estimated on the basis of very few sensible co-variates. EPCs are also only available on dwellings that have been sold since XXX or are currently rented. This excludes a sub-set of properties which are probably older and less energy efficient.
 * SAVE data: this sample of 4,000+ households from the Solent region has neither EPC or gas consumption data
 * NEED anonymised sample data: XX check XX
 * SERL smart meter data: this has all (or nearly all) of the attributes we need but 1) is for a sample of the population and 2) will not have complete EPC data since dwellings that are not rented or have not been recently sold will tend not to have an EPC.

## EPC-based models

Partial coverage, no household attributes so no distributional analysis

## NEED-based models

?

## SERL-based models

Data: https://beta.ukdataservice.ac.uk/datacatalogue/studies/study?id=8666#!/documentation

No income just has proxies:

 * Household level:
   * C3: Thinking about the working situation of each member of your household aged 16 and over, including you, how many would you say fall into each category below?
   * C4: Including you, how many people in your household hold a degree (e.g. BA, BSc) or higher qualification (e.g. MA, PhD, PGCE)?
 * Individual respondent:
   * D3: Which best describes your current employment
situation?
   * D4: How well would you say you yourself are managing financially these days? Would you say you are ...


## Summary

# Could this be done?

## Politically?

As we understand it local authorities can set council tax rates to 0 without triggering a referendum! But can they create a new local tax system of the kind we propose to replace it? Would it need new legislation? Or could it be created from a process that already exists? And if they then had to resurrect the Concil Tax to recover declining carbon tax revenue, would that automaticallly trigger a referendum?!

Perhaps more interestingly if a strongly 'green' local authority put a local tax system based on this approach to a local referendum with clear calculations of its effects for different social groups, would it be approved? From a purely rational self-interest persepctive it should if the majority would be better off because the bulk of the tax charge might fall on the higher emitters...

## Practically?

How would a local authority collect the data it needs at the dwelling level? Could it:

 * mandate full EPCs on all dwellings? Or charge a penalising rate to those that do not have them (they are not expensive to procure)
 * model likely consumption levels & emissions for each dwelling and so incentivise those whose emissons are actually lower to agree to the annual energy consumption being collected from their smart meters? But what to do about those who are higher?
 * mandate the collection of annual energy input data from the smart meter system for all dwellings, in much the same way that it is mandatory to declare income for tax purposes? The smart meter data includes tariff (XX check XX) and so carbon intensity (XX check XX)

# Should this be done?

Why not?

# Playing games

Inevitably any system that can be gamed for gain will be. Examples might include:

 * ?
 
We would need to think carefully how to structure the system to avoid this.

\newpage

# Emissions Levy Case Study

In the remoinder of this paper we develop a model of an emissions levy using LSOA level data on emissions derived from the CREDS place-based emissions calculator. We apply carbon 'values' to a number of emissions categories to estimate the levy revenue that would be generated for each LSOA in year 1 of such a levy. We then sum these values to given anoverall levy revenue estimate for the area in the case study.

We then use estimates of the cost of retrofitting EPC band dwellings D-E and F-G together with estimates of the number of such dwellings in each of the LSOAs to calculate the likely cost of such upgrades in each LSOA and for the whole area in the case study.

We then compare the distributions of the two to understand whether sufficient revenue would be generated within each LSOA or in the case styudy area to enable the per-LSOA or whole case study area costs of the energy efficiency upgrades to be met. In doing so we also analyse the extent to which redistribution of revenue from high emissions areas (households) would be required. 

It should be noted that this is area level analysis using mean emissions per household. It will not capture within-LSOA hetergeneity in emissions and so will almost certaonly underestimate the range of the household level emissions levy value.

# Data and boundary files
We will use a number of datasets to analyse the patterns of emissions. Some of these are in the repo as they are public access, others are not (or too large).

This anlaysis is at LSOA level.

## Useful LSOA labels and codes

Load lSOA look-up table

```{r loadLSOAlookup}

message("Loading LSOA look-up table with useful labels")
data$lsoa_lookup_solent <- data.table::fread(here::here("data", "LSOA_lookup_solent.csv.gz"))

```

## Boundaries

LSOA - this is all going to be LSOA analysis

```{r loadLSOA}
message ("Loading Solent LSOA boundaries from file")
# if you want a different area you'll need a different .shp file

boundaries$lsoa_solent <- sf::read_sf(here::here("data", "boundaries", "LSOA", "lsoa_solent.shp"))
message("Rows of data: ", nrow(boundaries$lsoa_solent))

message("Selecting Southampton")
# can't use function as sf not a data.table
boundaries$lsoa_soton <- filter(boundaries$lsoa_solent, LAD11NM == "Southampton")
message("Rows of data: ", nrow(boundaries$lsoa_soton))
```

Check with a map...

```{r simpleLSOAMap, fig.cap = "LSOA check map (shows LSOA, MSOA and ward names when clicked"}

st_coord_sys <- sf::st_crs(boundaries$lsoa_soton) # check coord system
message("Boundary data co-ord system: ", st_coord_sys$epsg)
# if required transform current coord system to EPSG: 4326 (is what leaflet wants - good)
# do this once here and then re-use
if(st_coord_sys$epsg != 4326){
 boundaries$lsoa_soton_leaflet <- st_transform(boundaries$lsoa_soton, "+proj=longlat +datum=WGS84")
}

# merge some of the LSOA labels to the boundaries so they can be in the map pop-up
boundaries$lsoa_soton_leaflet <- merge(boundaries$lsoa_soton_leaflet, data$lsoa_lookup_solent[, .(LSOA11CD, WD20CD, WD20NM)],
                                       by = "LSOA11CD")

leaflet(boundaries$lsoa_soton_leaflet) %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addPolygons(fillOpacity = 0.2, 
              weight = 1.5, 
              popup = ~(paste0("LSOA: ",LSOA11NM,
                               "<br> MSOA: " , MSOA11NM,
                               "<br> Ward: ", WD20NM,
                               "<br> LA: ", LAD11NM)
                      ), # popups clicked
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                fillOpacity = 0.7,
                bringToFront = TRUE))

```


## IMD 2019

Labeled as 2019 but actually 2018 data. Source: https://www.gov.uk/government/statistics/english-indices-of-deprivation-2019

```{r loadIMD2019}
data$lsoa_imd2019 <- data.table::fread(here::here("data", "LSOA_Indices_of_Multiple_Deprivation_2019.csv.gz")
                                  )
data$lsoa_imd2019[, LAD11NM := LADnm]
data$lsoa_imd2019[, IMD_Decile_label := ifelse(IMD_Decile == 1, "1 (10% most deprived)",IMD_Decile)]
data$lsoa_imd2019[, IMD_Decile_label := ifelse(IMD_Decile == 10, "10 (10% least deprived)",IMD_Decile_label)]

data$lsoa_imd2019[, IMD_Decile_label := factor(IMD_Decile_label, levels = c("1 (10% most deprived)","2","3","4","5","6","7","8","9","10 (10% least deprived)"))]
message("Overall IMD decile counts")
nrow(data$lsoa_imd2019)
table(data$lsoa_imd2019$IMD_Decile_label)                               
data$lsoa_imd2019_soton <- getSoton(data$lsoa_imd2019)

message("# Southampton IMD decile counts")
nrow(data$lsoa_imd2019_soton)
table(data$lsoa_imd2019_soton$IMD_Decile_label) 
```

These are LSOA level deprivation indices. Decile is the English & Welsh decile:

 * 1 = 10% most deprived LSOAs in England & Wales;
 * 10 = 10% least deprived LSOA in England & Wales.

```{r imdLSOAMap, fig.cap = "LSOA IMD map (shows LSOA, MSOA, ward names and IMD decile when clicked"}

boundaries$lsoa_soton_leaflet <- merge(boundaries$lsoa_soton_leaflet, data$lsoa_imd2019_soton[, .(LSOA11CD= lsoa11cd, IMDScore, IMD_Decile,IMD_Decile_label)],
                                       by = "LSOA11CD")

colCats <- colorNumeric("Reds", boundaries$lsoa_soton_leaflet$IMDScore, n = 9)

leaflet(boundaries$lsoa_soton_leaflet) %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addPolygons(color = ~colCats(IMDScore),
              fillOpacity = 0.6, 
              weight = 1.5, 
              popup = ~(paste0("LSOA: ",LSOA11NM,
                               "<br> MSOA: " , MSOA11NM,
                               "<br> Ward: ", WD20NM,
                               "<br> LA: ", LAD11NM,
                               "<br> IMD decile: ",IMD_Decile )
                      ), # popups clicked
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                fillOpacity = 0.8,
                bringToFront = TRUE))

```

## CREDS place-based emmissions estimates

See https://www.creds.ac.uk/why-we-built-a-place-based-carbon-calculator/

"The highest carbon areas have an average per person footprint more than eight times larger than the lowest carbon areas."

"We are not effectively targeting decarbonisation policies in high carbon areas. For example, the recently collapsed Green Homes Grants scheme provided a grant to cover 66% of the cost (up to £5,000) of retrofitting homes.  For people claiming certain benefits, the cap was raised to 100% and £10,000. But the calculator shows that the big polluters are the large homes in very wealthy areas. In these neighbourhoods, the issue is not affordability but motivation. For high income households, energy costs are a small proportion of their expenditure and so the cost savings for retrofitting their home are inconsequential. As there are no policy “sticks” to incentivise action in the collective interest it is unsurprising that high carbon neighbourhoods have not prioritised decarbonisation."

Source: https://www.carbon.place/

Notes:

 * Emissions are presented as per capita...
 * Appears to be based on residential/citizen emissions only - does not appear to include commercial/manufacturing/land use etc

```{r loadCREDSpbcc}
data$lsoa_creds_pbcc <- data.table::fread(here::here("data", "LSOA_CREDS_PBCC_data.csv.gz"))
# % of total emissions due to gas & elec & other heat
data$lsoa_creds_pbcc[, energy_pc := 100*((elec_percap_2018 + gas_percap_2018 + other_heat_percap_2011)/total_kgco2e_percap)]

nrow(data$lsoa_creds_pbcc)

# % of household (spaces?) with mainly elec
data$lsoa_creds_pbcc[, pc_Heating_Electric := 100*(pHeating_Electric/(pHeating_None + pHeating_Gas + pHeating_Electric + pHeating_Oil + pHeating_Solid+ pHeating_Other))]

data$lsoa_creds_pbcc[, LAD11NM := LAD17NM] # for matching - beware name changes

# calc totals ----
data$lsoa_creds_pbcc[, CREDStotal_kgco2e := total_kgco2e_percap * pop_2018]
data$lsoa_creds_pbcc[, CREDSgas_kgco2e2018 := gas_percap_2018 * pop_2018]
data$lsoa_creds_pbcc[, CREDSelec_kgco2e2018 := elec_percap_2018 * pop_2018]
data$lsoa_creds_pbcc[, CREDSotherEnergy_kgco2e2011 := other_heat_percap_2011 * pop_2018]
data$lsoa_creds_pbcc[, CREDSallHomeEnergy_kgco2e2011 := CREDSotherEnergy_kgco2e2011 + CREDSgas_kgco2e2018 + CREDSelec_kgco2e2018 + CREDSotherEnergy_kgco2e2011]
data$lsoa_creds_pbcc[, CREDScar_kgco2e2018 := car_percap_2018 * pop_2018]
data$lsoa_creds_pbcc[, CREDSvan_kgco2e2018 := van_percap_2018 * pop_2018]

# get analytic dataset ----
# reduced variable set for simplicity
# reduced LA if you wish - in this case Southampton

credsLsoaDT <- getSoton(data$lsoa_creds_pbcc[, .(LAD11NM, WD18NM, LSOA11CD = LSOA11, 
                                        CREDStotal_kgco2e,CREDSgas_kgco2e2018,CREDSelec_kgco2e2018,
                                        CREDSotherEnergy_kgco2e2011,CREDSallHomeEnergy_kgco2e2011,
                                        CREDScar_kgco2e2018,CREDSvan_kgco2e2018,
                                        pop_2018, energy_pc, pc_Heating_Electric,
                                        epc_total, epc_newbuild, epc_A, epc_B,
                                        epc_C, epc_D, epc_E, epc_F, epc_G)])


# add IMD etc
lsoa_imd2019_soton <- data$lsoa_imd2019_soton
lsoa_imd2019_soton[, LSOA11CD := lsoa11cd]
setkey(lsoa_imd2019_soton, LSOA11CD)

lsoa_lookup_solent <- data$lsoa_lookup_solent
setkey(lsoa_lookup_solent, LSOA11CD)

setkey(credsLsoaDT, LSOA11CD)
credsLsoaDT <- credsLsoaDT[lsoa_lookup_solent[, .(LSOA11CD, RUC11, oacSuperGroupName = `Supergroup Name`)]]

credsLsoaDT <- credsLsoaDT[lsoa_imd2019_soton[, .(LSOA11CD, IMD_Decile, IMDScore, IMD_Decile_label)]] # reduced set of vars

# run skim & eyeball for strange stuff - especially check:
# n rows - is this what you expect?
# n unique LAD11NM = number of LAs included
skimr::skim(credsLsoaDT)

# directly check LAs included (first 6 rows of table)
head(table(credsLsoaDT$LAD11NM))
```

Now we need to convert the per capita to totals and then use the number of electricity meters as a proxy for the number of dwellings

Ideally we'd have Census 2021 data but we don't have it yet. So instead we'll use the number of electricity meters for 2018 which aligns with the CREDS data (might be an over-estimate if a dwelling has 2...)

First check the n electricity meters logic...

```{r check_nElecMeters}
gasF <- here::here("data", "LSOA_GAS_2018.csv.gz")
gasDT <- data.table::fread(gasF)
gasDT[,LAD11NM := `Local Authority Name`]
gasDT[,LSOA11CD := `Lower Layer Super Output Area (LSOA) Code`]
soton_gas2018DT <- getSoton(gasDT)
setkey(soton_gas2018DT, LSOA11CD, LAD11NM)

elecF <- here::here("data", "LSOA_ELEC_2018.csv.gz")
elecDT <- data.table::fread(elecF)
elecDT[,LAD11NM := `Local Authority Name`]
elecDT[,LSOA11CD := `Lower Layer Super Output Area (LSOA) Code`]
soton_elec2018DT <- getSoton(elecDT)
setkey(soton_elec2018DT, LSOA11CD, LAD11NM)

energy_2018DT <- soton_elec2018DT[soton_gas2018DT]
energy_2018DT[, nGasMeters := `Number of consuming meters`]
energy_2018DT[, nElecMeters := `Total number of domestic electricity meters`]
setkey(energy_2018DT, LSOA11CD)

setkey(credsLsoaDT, LSOA11CD)
message("LSOAs (check): ")
nrow(credsLsoaDT)

credsLsoaDT <- credsLsoaDT[energy_2018DT]
```

Check that the number of electricity meters reasonably correlates with the number of EPCs from the CREDS data. We would _not_ expect the number of gas meters to correlate due to non-gas dwellings etc.

```{r checkDwellingCounts}
p <- credsLsoaDT[, .(BEIS_nGasMeters2018 = nGasMeters, 
                     BEIS_nElecMeters2018 = nElecMeters, 
                     CREDS_epc_total2018 = epc_total)]

pairs(p)
```

That assumption seems sensible... 

### Estimate per dwelling emissions

We want to present the analysis in 'per dwelling' or 'per household' terms so we need to convert the total kg CO2e values to per dwelling values by dividing by the number of electricity meters.

```{r estimatePerDwellingCO2e}

credsLsoaDT[, CREDStotal_kgco2e_pdw := CREDStotal_kgco2e/nElecMeters]

credsLsoaDT[, CREDSgas_kgco2e2018_pdw := CREDSgas_kgco2e2018/nElecMeters]

credsLsoaDT[, CREDSelec_kgco2e2018_pdw := CREDSelec_kgco2e2018/nElecMeters]

credsLsoaDT[, CREDSmeasuredHomeEnergy_kgco2e2018_pdw := (CREDSgas_kgco2e2018 + CREDSelec_kgco2e2018)/nElecMeters]

credsLsoaDT[, CREDSotherEnergy_kgco2e2011_pdw := CREDSotherEnergy_kgco2e2011/nElecMeters]

credsLsoaDT[, CREDSallHomeEnergy_kgco2e2018_pdw:= (CREDSelec_kgco2e2018 + CREDSgas_kgco2e2018 + CREDSotherEnergy_kgco2e2011)/nElecMeters]

credsLsoaDT[, CREDScar_kgco2e2018_pdw:= CREDScar_kgco2e2018/nElecMeters]

credsLsoaDT[, CREDSvan_kgco2e2018_pdw:= CREDSvan_kgco2e2018/nElecMeters]

credsLsoaDT[, CREDSpersonalTransport_kgco2e2018_pdw:= (CREDScar_kgco2e2018 + CREDSvan_kgco2e2018)/nElecMeters]

t <- summary(credsLsoaDT[, .(CREDStotal_kgco2e_pdw,CREDSgas_kgco2e2018_pdw,CREDSelec_kgco2e2018_pdw,
                             CREDSmeasuredHomeEnergy_kgco2e2018_pdw,
                             CREDSotherEnergy_kgco2e2011_pdw, CREDSallHomeEnergy_kgco2e2018_pdw,
                             CREDScar_kgco2e2018_pdw, CREDSvan_kgco2e2018_pdw, CREDSpersonalTransport_kgco2e2018_pdw) ])

message("# Summary of per dwelling values")
t
```

Examine patterns of per dwelling emissions for sense.

#### All emissions

Figure \@ref(fig:visIMDallCO2eperdw) shows the LSOA level per dwelling 'all emissions' in Tonnes CO2e as estimated by the CREDS tool against the Index of Multiple Deprivation (IMD) score and uses the size of the points to represent the % of dwellings with electric heating. Colour is used to represent the IMD decile where decile 1 is the 10% least deprived.

```{r visIMDallCO2eperdw, fig.height = 5, fig.cap="Scatter of LSOA level all per dwelling emissions against IMD score"}
message("Per dwelling T CO2e - all emissions")

# if this is all LSOAs in a larger area might want to use RUC11 instead of IMD_Decile_label to look at
# urban/rural distirbutions
ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, y = CREDStotal_kgco2e_pdw/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "IMD 2019 score",
       y = "Estimated total T CO2e/household (CREDS, 2021)")
ggplot2::ggsave(filename = here::here("plots/scatterIMD_CREDStotal_kgco2e_pdw.png"))

message("Correlation test (pwcorr)")
cor.test(credsLsoaDT$IMDScore, credsLsoaDT$CREDStotal_kgco2e_pdw)

t <- credsLsoaDT[, .(LSOA11CD, WD18NM, All_Tco2e_per_dw = CREDStotal_kgco2e_pdw/1000)]

head(t[order(-All_Tco2e_per_dw)])

tail(t[order(-All_Tco2e_per_dw)])

sf <- merge(boundaries$lsoa_soton_leaflet, t, by = "LSOA11CD")

colCats <- colorNumeric("Reds", t$All_Tco2e_per_dw, n = 9)

leaflet(sf) %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addPolygons(color = ~colCats(All_Tco2e_per_dw),
              fillOpacity = 0.6, 
              weight = 1.5, 
              popup = ~(paste0("LSOA: ",LSOA11NM,
                               "<br> Ward: ", WD20NM,
                               "<br> T CO2e/dwelling: ", dkUtils::tidyNum(round(All_Tco2e_per_dw)))
                      ), # popups clicked
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                fillOpacity = 0.8,
                bringToFront = TRUE))




```

#### Home energy use

Figure \@ref(fig:visIMDgasCO2eperdw) uses the same plotting method to show emissions per dwelling due to gas use. This preserves the negative correlation shown in the previou splot for 'all emissions' but with some variation, notably for LSOAs which have a higher % ofelectric heating.

```{r visIMDgasCO2eperdw, fig.height = 5, fig.cap="Scatter of LSOA level gas per dwelling emissions against IMD score"}

message("Per dwelling T CO2e - gas emissions")

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, y = CREDSgas_kgco2e2018_pdw/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "IMD 2019 score",
       y = "Estimated gas T CO2e/household (CREDS, 2021)")
ggplot2::ggsave(filename = here::here("plots/scatterIMD_CREDSgas_kgco2e2018_pdw.png"))

message("Correlation test (pwcorr)")
cor.test(credsLsoaDT$IMDScore, credsLsoaDT$CREDSgas_kgco2e2018_pdw)
```

Figure \@ref(fig:visIMDelecCO2eperdw) uses the same plotting method to show emissions per dwelling due to electricity use. This is mnuch more random... although note the LSOAs with higher % electric heating.

```{r visIMDelecCO2eperdw, fig.height = 5, fig.cap="Scatter of LSOA level elec per dwelling emissions against IMD score - who emits?"}

message("Per dwelling T CO2e - elec emissions")

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, y = CREDSelec_kgco2e2018_pdw/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "IMD 2019 score",
       y = "Estimated electricity T CO2e/household (CREDS, 2021)")
ggplot2::ggsave(filename = here::here("plots/scatterIMD_CREDSelec_kgco2e2018_pdw.png"))

message("Correlation test (pwcorr)")
cor.test(credsLsoaDT$IMDScore, credsLsoaDT$CREDSelec_kgco2e2018_pdw)

```


Figure \@ref(fig:visIMDotherEnergyCO2eperdw) uses the same plotting method to show emissions per dwelling due to other energy use. This should be higher for off-gas areas which tend to be rural areas so we also present analysis by the LSOA's urban/rural classification.

```{r visIMDotherEnergyCO2eperdw, fig.height = 5, fig.cap="Scatter of LSOA level other energy per dwelling emissions against IMD score - who emits?"}

message("Per dwelling T CO2e - elec emissions")

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, y = CREDSotherEnergy_kgco2e2011_pdw/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "IMD 2019 score",
       y = "Estimated electricity T CO2e/household (CREDS, 2021)")
ggplot2::ggsave(filename = here::here("plots/scatterIMD_CREDSotherEnergy_kgco2e2018_pdw.png"))

message("Correlation test (pwcorr)")
cor.test(credsLsoaDT$IMDScore, credsLsoaDT$CREDSelec_kgco2e2018_pdw)

credsLsoaDT[, .(mean_gas_kgco2e = mean(CREDSgas_kgco2e2018_pdw),
                mean_elec_kgco2e = mean(CREDSelec_kgco2e2018_pdw),
                mean_other_energy_kgco2e = mean(CREDSotherEnergy_kgco2e2011_pdw)), 
                keyby = .(RUC11)] # only sensible for case styudy area which is a mix of urban/rural

```

Check whether all _measured_ energy emissions combined (gas & electricity) correlate with all emissions (in this data).

```{r correlateAllandMeasuredEnergyEmissions}

cor.test(credsLsoaDT$CREDStotal_kgco2e_pdw, credsLsoaDT$CREDSmeasuredHomeEnergy_kgco2e2018_pdw)

ggplot2::ggplot(credsLsoaDT, aes(x = CREDStotal_kgco2e_pdw/1000, 
                                 y = CREDSmeasuredHomeEnergy_kgco2e2018_pdw/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Estimated total T CO2e/household (CREDS, 2021)",
       y = "Estimated measured energy T CO2e/household (CREDS, 2021)")
ggplot2::ggsave(filename = here::here("plots/scatterCREDStotal_kgco2e_pdw_CREDSmeasuredHomeEnergy_kgco2e2018_pdw.png"))
```

Strong correlkation. So in theory we could (currently) use measured energy emissions as a proxy for total emissions.

Repeat for all home energy - includes estimates of emissions from oil etc

```{r correlateAllandHomeEnergyEmissions}

cor.test(credsLsoaDT$CREDStotal_kgco2e_pdw, credsLsoaDT$CREDSallHomeEnergy_kgco2e2018_pdw)

ggplot2::ggplot(credsLsoaDT, aes(x = CREDStotal_kgco2e_pdw/1000, 
                                 y = CREDSallHomeEnergy_kgco2e2018_pdw/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Estimated total T CO2e/household (CREDS, 2021)",
       y = "Estimated total home energy T CO2e/household (CREDS, 2021)")
ggplot2::ggsave(filename = here::here("plots/scatterCREDStotal_kgco2e_pdw_CREDSmeasuredHomeEnergy_kgco2e2018_pdw.png"))
```

Slightly weaker correlation...

#### Transport

We don't expect to use this data as it is already taxed in a way that relates to emissions (?)

Figure \@ref(fig:visIMDcarCO2eperdw) uses the same plotting method to show emissions per dwelling due to van use. Again, we present analysis by the LSOA's urban/rural classification.

```{r visIMDcarCO2eperdw, fig.height = 5, fig.cap="Scatter of LSOA level car use per dwelling emissions against IMD score"}

message("Per dwelling T CO2e - car emissions")

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, y = CREDScar_kgco2e2018_pdw/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "IMD 2019 score",
       y = "Estimated electricity T CO2e/household (CREDS, 2021)")
ggplot2::ggsave(filename = here::here("plots/scatterIMD_CREDScar_kgco2e2018_pdw.png"))

message("Correlation with IMD score (pwcorr)")
cor.test(credsLsoaDT$IMDScore, credsLsoaDT$CREDScar_kgco2e2018_pdw)

credsLsoaDT[, .(mean_car_kgco2e = mean(CREDScar_kgco2e2018_pdw),
                mean_van_kgco2e = mean(CREDSvan_kgco2e2018_pdw)), 
                keyby = .(RUC11)] # only sensible for case styudy area which is a mix of urban/rural

```

Figure \@ref(fig:visIMDvanCO2eperdw) uses the same plotting method to show emissions per dwelling due to van use.

```{r visIMDvanCO2eperdw, fig.height = 5, fig.cap="Scatter of LSOA level van use per dwelling emissions against IMD score"}

message("Per dwelling T CO2e - van emissions")

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, y = CREDSvan_kgco2e2018_pdw/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "IMD 2019 score",
       y = "Estimated van use T CO2e/household (CREDS, 2021)")
ggplot2::ggsave(filename = here::here("plots/scatterIMD_CREDSvan_kgco2e2018_pdw.png"))

message("Correlation with IMD score (pwcorr)")
cor.test(credsLsoaDT$IMDScore, credsLsoaDT$CREDSvan_kgco2e2018_pdw)

```

### Impute EPC counts

In order to estimate the LSOA level retrofit costs, we need to impute the EPC counts in each LSOA. We do this using the number of electricity meters as the presumed number of dwellings and the observed % of EPCs in each band for all dwellings with EPCs which is provided by the CREDS data. This _assumes_ that if we had EPCs for all dwellings then the % in each band in each LSOA would stay the same. This is quite a bold assumption...

Note that the EPC database is continuously updated so more recent upgrades will not be captured in the data used for this analysis. This means the total retrofit costs are likely to be an over-estimate. The extent of this over-estimate would require the use of an updated (current) EPC data extract and is left for future work.

```{r impute_EPC_counts}
# CREDS data has counts - we know there are missing EPCs
message("N EPCs")
summary(credsLsoaDT$epc_total)
message("N elec meters")
summary(credsLsoaDT$nElecMeters)

# We will assume the distribution of EPCs across bands within LSOAs is unbiased
# So the % will be OK but the count will be wrong
credsLsoaDT[, epc_A_pc := epc_A/epc_total]
credsLsoaDT[, epc_B_pc := epc_B/epc_total]
credsLsoaDT[, epc_C_pc := epc_C/epc_total]
credsLsoaDT[, epc_D_pc := epc_D/epc_total]
credsLsoaDT[, epc_E_pc := epc_E/epc_total]
credsLsoaDT[, epc_F_pc := epc_F/epc_total]
credsLsoaDT[, epc_G_pc := epc_G/epc_total]

credsLsoaDT[, epc_A_imp := epc_A_pc * nElecMeters] # rebase using nElecMeters
credsLsoaDT[, epc_B_imp := epc_B_pc * nElecMeters]
credsLsoaDT[, epc_C_imp := epc_C_pc * nElecMeters]
credsLsoaDT[, epc_D_imp := epc_D_pc * nElecMeters]
credsLsoaDT[, epc_E_imp := epc_E_pc * nElecMeters]
credsLsoaDT[, epc_F_imp := epc_F_pc * nElecMeters]
credsLsoaDT[, epc_G_imp := epc_G_pc * nElecMeters]
```

Correlation between high % EPC F/G or A/B and deprivation?

```{r plotEPC_pc}
ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, y = epc_F_pc + epc_G_pc)) +
  geom_point() +
  geom_smooth()

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, y = epc_A_pc + epc_B_pc)) +
  geom_point() +
  geom_smooth()
```

Now we need to convert the % to dwellings using the number of electricity meters (see above).

```{r plotEPC_impute}
ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, y = epc_F_imp + epc_G_imp)) +
  geom_point() +
  geom_smooth()

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, y = epc_A_imp + epc_B_imp)) +
  geom_point() +
  geom_smooth()
```

## Fuel poverty

2019 estimates - do we acttually use this data?

Source: https://www.gov.uk/government/statistics/sub-regional-fuel-poverty-data-2021


```{r loadBEISFP}
data$lsoa_beis_fp <- data.table::fread(here::here("data", "LSOA_Fuel_Poverty_2019.csv.gz"))
```


## Estimating the annual emissions levy

Case studies:

 * Annual carbon tax
 * Half-hourly (real time) carbon tax (_not implemented_) - this would only affect electrcity

BEIS/ETC Carbon ‘price’

 * 2020 - £21.93 https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/849276/Carbon__Penalty_Price_Determination_for_2020.pdf 

EU carbon ‘price’

 * September 2021: €60 (£51) https://tradingeconomics.com/eecxm:ind

BEIS Carbon ‘Value’ https://www.gov.uk/government/publications/valuing-greenhouse-gas-emissions-in-policy-appraisal/valuation-of-greenhouse-gas-emissions-for-policy-appraisal-and-evaluation#annex-1-carbon-values-in-2020-prices-per-tonne-of-co2

 * based on a Marginal Abatement Cost (MAC)
 * 2021: 
    * Low: £122/T
    * Central: £245/T <- use the central value for now
    * High: £367/T

```{r estimateAnnualLevy}
# carbon costs
eu_ets <- 51
beis_l <- 122
beis_c <- 245
beis_h <- 367

credsLsoaDT[, eu_ets_GBPtotal := CREDStotal_kgco2e/1000 * eu_ets] # £ in tonnes so /1000
credsLsoaDT[, eu_ets_GBPtotal_perdw := eu_ets_GBPtotal/nElecMeters]

credsLsoaDT[, beis_GBPtotal_l := CREDStotal_kgco2e/1000 * beis_l]
credsLsoaDT[, beis_GBPtotal_l_perdw := beis_GBPtotal_l/nElecMeters]
credsLsoaDT[, beis_GBPtotal_l_gas := CREDSgas_kgco2e2018/1000 * beis_l]
credsLsoaDT[, beis_GBPtotal_l_elec := CREDSelec_kgco2e2018/1000 * beis_l]
credsLsoaDT[, beis_GBPtotal_l_gas_perdw := beis_GBPtotal_l_gas/nElecMeters]
credsLsoaDT[, beis_GBPtotal_l_elec_perdw := beis_GBPtotal_l_elec/nElecMeters]

credsLsoaDT[, beis_GBPtotal_c := CREDStotal_kgco2e/1000 * beis_c]
credsLsoaDT[, beis_GBPtotal_c_perdw := beis_GBPtotal_c/nElecMeters]
credsLsoaDT[, beis_GBPtotal_c_gas := CREDSgas_kgco2e2018/1000 * beis_c]
credsLsoaDT[, beis_GBPtotal_c_elec := CREDSelec_kgco2e2018/1000 * beis_c]
credsLsoaDT[, beis_GBPtotal_c_gas_perdw := beis_GBPtotal_c_gas/nElecMeters]
credsLsoaDT[, beis_GBPtotal_c_elec_perdw := beis_GBPtotal_c_elec/nElecMeters]

credsLsoaDT[, beis_GBPtotal_h := CREDStotal_kgco2e/1000 * beis_h]
credsLsoaDT[, beis_GBPtotal_h_gas := CREDSgas_kgco2e2018/1000 * beis_h]
credsLsoaDT[, beis_GBPtotal_h_elec := CREDSelec_kgco2e2018/1000 * beis_h]
credsLsoaDT[, beis_GBPtotal_h_perdw := beis_GBPtotal_h/nElecMeters]
credsLsoaDT[, beis_GBPtotal_h_gas_perdw := beis_GBPtotal_h_gas/nElecMeters]
credsLsoaDT[, beis_GBPtotal_h_elec_perdw := beis_GBPtotal_h_elec/nElecMeters]

credsLsoaDT[, beis_GBPtotal_c_energy := beis_GBPtotal_c_gas + beis_GBPtotal_c_elec]
credsLsoaDT[, beis_GBPtotal_c_energy_perdw := beis_GBPtotal_c_gas_perdw + beis_GBPtotal_c_elec_perdw]
```


The table below shows the ovwrall £ GBP total for the case study area in £M.

```{r GBP_beis_c}
m <- 1000000
t <- credsLsoaDT[, .(beis_GBPtotal_c = sum(beis_GBPtotal_c)/m,
                     beis_total_c_gas = sum(beis_GBPtotal_c_gas)/m,
                     beis_GBPtotal_c_elec = sum(beis_GBPtotal_c_elec)/m)]

round(t,2)
```

The table below shows the mean per dwelling value rounded to the nearest £10.

```{r GBP_beis_perdw}

t <- credsLsoaDT[, .(beis_GBPtotal_c_perdw = mean(beis_GBPtotal_c_perdw),
                     beis_GBPtotal_c_gas_perdw = mean(beis_GBPtotal_c_gas_perdw),
                     beis_GBPtotal_c_elec_perdw = mean(beis_GBPtotal_c_elec_perdw),
                     beis_GBPtotal_c_energy_perdw = mean(beis_GBPtotal_c_energy_perdw))]

round(t,-1)

```


Figure \@ref(fig:whoWinsBEIScAll) shows the total £k per LSOA and £ per dwelling revenue using BEIS central carbon price plotted against IMD score. The tables show the LSOAs with the highest and lowest values.

```{r whoWinsBEIScAll, fig.cap = "£k per LSOA revenue using BEIS central carbon price"}
emissionsCap <- "All emissions"
  
ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_c/1000)) +
  geom_point(aes(colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon value' £k total",
       caption = emissionsCap)
ggplot2::ggsave(filename = here::here("plots/whoWins_beis_GBPtotal_c.png"))

med <- median(credsLsoaDT$beis_GBPtotal_c_perdw)

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_perdw)) +
  geom_hline(yintercept = med, colour = "orange") +
  geom_point(aes(colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon value' £ per dwelling",
       caption = emissionsCap)
ggplot2::ggsave(filename = here::here("plots/whoWins_beis_GBPtotal_c_perdw.png"))

summary(credsLsoaDT$beis_GBPtotal_c_perdw)

t <- credsLsoaDT[, .(LSOA11CD, WD18NM, beis_GBPtotal_c, beis_GBPtotal_c_perdw)]

head(t[order(-beis_GBPtotal_c_perdw)])

tail(t[order(-beis_GBPtotal_c_perdw)])
```

Figure \@ref(fig:whoWinsBEIScGas) repeats the analysis but just for gas.

```{r whoWinsBEIScGas, fig.cap = "£k per LSOA incurred via gas using BEIS central carbon price"}
emissionsCap <- "Emissions due to gas"

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_gas/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon value' £k",
       caption = emissionsCap)
ggplot2::ggsave(filename = here::here("plots/whoWinsBEIS_c_gas_total.png"))

med <- median(credsLsoaDT$beis_GBPtotal_c_gas_perdw)

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_gas_perdw)) +
  geom_hline(yintercept = med, colour = "orange") +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon value' £ per dwelling",
       caption = emissionsCap)
ggplot2::ggsave(filename = here::here("plots/whoWinsBEIS_c_gas_perdw.png"))

summary(credsLsoaDT$beis_GBPtotal_c_gas_perdw)
```

 Figure \@ref(fig:whoWinsBEIScElec) repeats the analysis for electricity.

```{r whoWinsBEIScElec, fig.cap = "£k per LSOA incurred via electricity using BEIS central carbon price"}

emissionsCap <- "Emissions due to electricity"

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_elec/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon value' £k",
       caption = emissionsCap)
ggplot2::ggsave(filename = here::here("plots/whoWinsBEIS_c_elec_total.png"))

med <- median(credsLsoaDT$beis_GBPtotal_c_elec_perdw)

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_elec_perdw)) +
  geom_hline(yintercept = med, colour = "orange") +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon value' £ per dwelling",
       caption = emissionsCap)
ggplot2::ggsave(filename = here::here("plots/whoWinsBEIS_c_elec_perdw.png"))

summary(credsLsoaDT$beis_GBPtotal_c_elec_perdw)
```

Figure \@ref(fig:whoWinsBEIScEnergy) shows the same analysis for measured energy (elec + gas)

```{r whoWinsBEIScEnergy, fig.cap = "£k per LSOA incurred via electricity and gas using BEIS central carbon price"}

emissionsCap <- "Emissions due to electricity & gas"

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_energy/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon value' £k",
       caption = emissionsCap)
ggplot2::ggsave(filename = here::here("plots/whoWinsBEIS_c_energy_total.png"))

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_energy_perdw)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon value' £ per dwelling",
       caption = emissionsCap)
ggplot2::ggsave(filename = here::here("plots/whoWinsBEIS_c_energy_perdw.png"))

summary(credsLsoaDT$beis_GBPtotal_c_energy_perdw)
```

### Estimate retofit costs

fromAE <- 13300
fromFG <- 26800

Excludes EPC A, B & C (assumes no need to upgrade)

```{r estRetrofitCosts}

fromAE <- 13300
fromFG <- 26800
credsLsoaDT[, retrofitDE := (epc_D_imp + epc_E_imp) * fromAE] # exclude epc_A_imp
credsLsoaDT[, retrofitFG := (epc_F_imp + epc_G_imp) * fromFG]
credsLsoaDT[, sumDE := (epc_D_imp + epc_E_imp)]
credsLsoaDT[, sumFG := (epc_F_imp + epc_G_imp)]

credsLsoaDT[, retrofitSum := retrofitDE + retrofitFG]
credsLsoaDT[, retrofitMeanPerDw := retrofitSum/(epc_D_imp + epc_E_imp + epc_F_imp + epc_G_imp)]

message("To retrofit D-E")
sum(credsLsoaDT$retrofitDE)
message("Number of dwellings: ", round(sum(credsLsoaDT$sumDE)))

message("To retrofit F-G")
sum(credsLsoaDT$retrofitFG)
message("Number of dwellings: ", round(sum(credsLsoaDT$sumFG)))

message("To retrofit D-G")
sum(credsLsoaDT$retrofitSum)

message("To retrofit D-G (mean per dwelling)")
mean(credsLsoaDT$retrofitMeanPerDw)

credsLsoaDT[, .(meanPerLSOA = mean(retrofitSum))]

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, y = retrofitSum/1000000)) +
  geom_point(aes(colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Total retrofit cost (£M)")
ggplot2::ggsave(filename = here::here("plots", "sotonLSOA_retrofitSum.png"))

ggplot2::ggplot(credsLsoaDT, aes(x = IMD_Decile_label, 
                            y = retrofitSum/1000000,
                            colour = IMD_Decile_label)) +
  geom_boxplot() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Total retrofit cost (£M)")

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, y = retrofitMeanPerDw)) +
  geom_point(aes(colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Mean retrofit cost per dwelling (£)")
ggplot2::ggsave(filename = here::here("plots", "sotonLSOA_retrofit_per_dwelling.png"))

ggplot2::ggplot(credsLsoaDT, aes(x = IMD_Decile_label, y = retrofitMeanPerDw)) +
  geom_boxplot() +
  labs(y = "Mean retrofit cost per dwelling (£)")
```

Map cost

```{r credsLSOAMapRetrofitCost, fig.cap = "LSOA retrofit costs (upgrade EPC C to F)"}

credsLsoaDT_sf <- merge(boundaries$lsoa_soton_leaflet, credsLsoaDT, by = "LSOA11CD")

colCats <- colorNumeric("Reds", credsLsoaDT_sf$retrofitSum, n = 9)

leaflet(credsLsoaDT_sf) %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addPolygons(color = ~colCats(retrofitSum),
              fillOpacity = 0.6, 
              weight = 1.5, 
              popup = ~(paste0("LSOA: ",LSOA11NM,
                               "<br> Ward: ", WD20NM,
                               "<br> % EPC A-C: ",round(100*(epc_A_pc + epc_B_pc + epc_C_pc)), " %",
                               "<br> % EPC D-E: ",round(100*(epc_D_pc + epc_E_pc)), " %", # it's actually a proportion not a %
                               "<br> % EPC F-G: ",round(100*(epc_F_pc + epc_G_pc)), " %",
                               "<br> Retrofit cost: £",round(retrofitSum/1000000,2), " M")
                      ), # popups clicked
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                fillOpacity = 0.8,
                bringToFront = TRUE))





t <- credsLsoaDT[, .(LSOA11CD, WD18NM, # NB not WD20NM
                epc_pc_A_C = 100*(epc_A_pc + epc_B_pc + epc_C_pc),
                retrofitSum)]

head(t[order(retrofitSum)])

head(t[order(-retrofitSum)])
```

### Compare levy with costs

```{r co2eToRettofitTotal, fig.height=5}
ggplot2::ggplot(credsLsoaDT, aes(x = beis_GBPtotal_c/1000, y = retrofitSum/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Total estimated levy (all emissions, £k)",
       y = "Dwelling retrofit cost (£k)")

ggplot2::ggsave(filename = here::here("plots/whoWins_RetrofitCost_beis_GBPtotal_c.png"))

ggplot2::ggplot(credsLsoaDT, aes(x = (beis_GBPtotal_c_gas + beis_GBPtotal_c_elec)/1000, y = retrofitSum/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Total estimated levy (energy, £k)",
       y = "Dwelling retrofit cost (£k)")

ggplot2::ggsave(filename = here::here("plots/whoWins_RetrofitCost_beis_GBPtotal_c_energy.png"))
```

Repeat per dwelling

```{r co2eToRettofitPerDwelling, fig.height=5}
ggplot2::ggplot(credsLsoaDT, 
                aes(x = beis_GBPtotal_c_perdw, y = retrofitMeanPerDw)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Mean emissions levy (all emissions, £)",
       y = "Mean dwelling retrofit cost (£)")
ggplot2::ggsave(filename = here::here("plots/whoWins_RetrofitCost_beis_GBPtotal_c_perdw.png"))

ggplot2::ggplot(credsLsoaDT, aes(x = (beis_GBPtotal_c_gas_perdw + beis_GBPtotal_c_elec_perdw), y = retrofitMeanPerDw)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Mean emissions levy per dwelling due to energy (£)",
       y = "Mean dwelling retrofit cost (£k)")

ggplot2::ggsave(filename = here::here("plots/whoWins_RetrofitCost_beis_GBPtotal_c_energy_perdw.png"))
```


### Years to pay...

```{r allLevyPayOff, fig.height=5}

credsLsoaDT[, yearsRequiredToPayRetrofit_beis_GBPtotal_c_perdw := retrofitMeanPerDw/beis_GBPtotal_c_perdw]
summary(credsLsoaDT$yearsRequiredToPayRetrofit_beis_GBPtotal_c_perdw)

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, 
                            y = yearsRequiredToPayRetrofit_beis_GBPtotal_c_perdw)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  geom_hline(yintercept = median(credsLsoaDT$yearsRequiredToPayRetrofit_beis_GBPtotal_c_perdw), colour = "orange") +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Years to pay off",
       caption = "BEIS central carbon value, all emissions levy")
ggplot2::ggsave(filename = here::here("plots/whoWins_yearsRequiredToPayRetrofit_beis_GBPtotal_c_perdw.png"))

```

```{r energyLevyPayOff, fig.height=5}
credsLsoaDT[, yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw := retrofitMeanPerDw/(beis_GBPtotal_c_gas_perdw + beis_GBPtotal_c_elec_perdw)]

summary(credsLsoaDT$yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw)

ggplot2::ggplot(credsLsoaDT, aes(x = IMDScore, 
                            y = yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  geom_hline(yintercept = median(credsLsoaDT$yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw), colour = "orange") +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Years to pay off",
       caption = "BEIS central carbon value, gas emissions levy\n(excludes LSOA with 0 gas)")
ggplot2::ggsave(filename = here::here("plots/whoWins_yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw.png"))

```


```{r transferVisAll}
plotDT <- credsLsoaDT[, .(LSOA11CD, beis_GBPtotal_c, beis_GBPtotal_c_elec, beis_GBPtotal_c_gas, retrofitSum, WD18NM, IMDScore)]
share_Y1_total_c <- sum(plotDT$beis_GBPtotal_c)/uniqueN(plotDT$LSOA11CD) # divide the year 1 levy equally
share_Y1_energy_c <- (sum(plotDT$beis_GBPtotal_c_elec) + sum(plotDT$beis_GBPtotal_c_gas))/uniqueN(plotDT$LSOA11CD) # divide the year 1 levy equally


plotDT[, surplusY1_total_c := share_Y1_total_c - retrofitSum] # equal share

plotDT[, surplusY1_energy_c := share_Y1_energy_c - retrofitSum]

ggplot2::ggplot(plotDT, aes(x = reorder(LSOA11CD, -retrofitSum), fill = retrofitSum/1000000)) +
  geom_col(aes(y = retrofitSum/1000000)) +
  geom_point(aes(y = share_Y1_total_c/1000000, colour = "Levy Year 1")) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  scale_fill_continuous(name = "Retrofit cost (£M)") +
  scale_color_discrete(name = "Levy Year 1 (£M)") +
  facet_wrap(. ~ WD18NM, scales="free_x") +
  labs(x = "LSOAs (ordered by retrofit cost)",
       y = "£M",
       caption = "BEIS central carbon value, all emissions levy")

ggplot2::ggsave(filename = here::here("plots/transferVis_allEmissions_c.png"))

ggplot2::ggplot(plotDT, aes(x = reorder(LSOA11CD, -retrofitSum), colour = WD18NM,
                            y = surplusY1_total_c/1000000)) +
                  geom_point() +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  geom_hline(yintercept = 0, colour = "red") +
  scale_color_discrete(name = "Ward") +
  labs(x = "LSOAs (ordered by retrofit cost)",
       y = "Year 1 surplus (£M)",
       caption = "BEIS central carbon value, all emissions levy")
ggplot2::ggsave(filename = here::here("plots/surplusVis_allEmissions_c.png"))
```

```{r transferVisEnergy}
ggplot2::ggplot(plotDT, aes(x = reorder(LSOA11CD, -retrofitSum), fill = retrofitSum/1000000)) +
  geom_col(aes(y = retrofitSum/1000000)) +
  geom_point(aes(y = share_Y1_energy_c/1000000, colour = "Levy Year 1")) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  scale_fill_continuous(name = "Retrofit cost (£M)") +
  scale_color_discrete(name = "Levy Year 1 (£M)") +
  facet_wrap(. ~ WD18NM, scales="free_x") +
  labs(x = "LSOAs (ordered by retrofit cost)",
       y = "£M",
       caption = "BEIS central carbon value, energy emissions levy")

ggplot2::ggsave(filename = here::here("plots/transferVis_energyEmissions_c.png"))

ggplot2::ggplot(plotDT, aes(x = reorder(LSOA11CD, -retrofitSum), colour = WD18NM,
                            y = surplusY1_energy_c/1000000)) +
                  geom_point() +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  geom_hline(yintercept = 0, colour = "red") +
  scale_color_discrete(name = "Ward") +
  labs(x = "LSOAs (ordered by retrofit cost)",
       y = "Year 1 surplus (£M)",
       caption = "BEIS central carbon value, energy emissions levy")
ggplot2::ggsave(filename = here::here("plots/surplusVis_energyEmissions_c.png"))

```
What happens in Year 2 totally depends on the rate of upgrades...
# R environment

## R packages used

* base R [@baseR]
* bookdown [@bookdown]
* data.table [@data.table]
* ggplot2 [@ggplot2]
* kableExtra [@kableExtra]
* knitr [@knitr]
* rmarkdown [@rmarkdown]
* skimr [@skimr]

## Session info


# Data Tables

I don't know if this will work...

```{r skimTables}
# tables <- names(data)
# for(t in tables){
#   print(lapply(tables, FUN(x) skimr::skim(data$eval(t)))
# }
message("Doesn't")
```

# References

