---
title: "Exploring local carbon tax models"
subtitle: "Southampton as a case study"
author: 'Ben Anderson (b.anderson@soton.ac.uk) & Tom Rushby'
date: 'Last run at: `r Sys.time()`'
output:
  bookdown::html_document2:
    self_contained: no
    fig_caption: yes
    code_folding: hide
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: TRUE
  bookdown::word_document2:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 2
    fig_width: 5
  bookdown::pdf_document2:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 2
bibliography: '`r path.expand("~/bibliography.bib")`'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```

\newpage

# Introduction

```{r rmdSetup, include=FALSE}

# Libraries ----
library(dkUtils) # see https://github.com/dataknut/dkUtils
myLibs <- c("tidyverse", # load first so that data.table masks (we only use tidyverse in one context - to filter sf)
            "data.table",
          "flextable",
          "ggplot2",
          "here",
          "leaflet",
          "skimr",
          "sf",
          "viridisLite")

dkUtils::loadLibraries(myLibs)

# Parameters ----

rmdParams <- list()

# Functions ----

source(here::here("R", "functions.R"))

```

Taxes are not just a way to generate revenue, they are also a means to incentivise 'good' things and dis-incentivise 'bad' things. Think tobacco & alcohol duty, sugar taxes, vehicle emissions and so on. Local taxes on the other hand do not seem to follow the same approach. The [Council Tax](https://www.local.gov.uk/topics/finance-and-business-rates/local-taxation-council-tax-and-business-rates), of which local authorities keep 100%, doesn't really incentivise anything at all as it's based on a notional dwelling value. The same is true of business rates, based on the rental value of the property, of which local authorities keep 50% with some discussion of [making this 100%](https://www.local.gov.uk/topics/finance-and-business-rates/business-rates-retention) in future.

Interestingly council tax rates are set by local authorities within a 'referendable' threshold. A rise above that threshold triggers a local referendum. We return to this later.

In the current 'climate emergency' both central and local governments are considering ways to force greenhouse gas emissions reductions through increased energy efficiency standards for new-builds and large scale investment in energy efficiency and low carbon heating retrofit. Some of this discussion has also focused on lobbying [to remove the VAT due on retrofit](https://www.architectsjournal.co.uk/news/vat-chance-can-tax-reforms-spur-a-retrofit-renaissance) work on the basis that the exisiting approach can incentivise complete reconstruction, with increased embodied carbon emissions, rather than retrofit which generally (?) has less.

In this paper we explore an extension of this concept by using the local tax system to incentivise dwelling owners to reduce their local tax charge by tying a new `local carbon tax` rate to the emissions 'band' of the dwelling. In this model the higher the emissions attributable to the dwelling, the higher the local carbon tax levied.

Clearly such an approach _could_ simply replace the council tax and possibly also the business rates although we focus here on residential dwellings alone. However this would cause a significant inequity for tenants who [currently pay council tax](https://www.gov.uk/council-tax/who-has-to-pay), would be  unable to make energy efficiency or low carbon energy investments in their home but would still have to pay whatever local carbon tax rate applied to the dwelling. We therefore propose two forms of local carbon tax, one that focuses on incentivising low carbon building structures and one which focuses on reducing emissiomns caused by the behaviour of the occupant themselves. Both will act to reduce emissions. We do this by:

 * a `local dwelling fabric carbon tax` - paid by building (dwelling) owners based on some proxy for (or an actual calculation of) the total GHG emissions due to space heating;
 * a `local consumption carbon tax` - paid by occupants based on an some proxyfor (or actual calculation of) the emissions due to total energy consumption less those that 'should' be due to space heating. Obviously if an occupant over-heats the dwelling, they will then be paying more tax... and vice versa (yes?).

This is an attmept to seperate the 'responsibility' of the dwelling owner for increasing the energy efficiency and reducing the emissions due to the building fabric from the responsibility of the 'occupant' for the _as lived_ emissions. In many cases these will be the same individual(s) but not in the case of tenants. It is regularly observed that dwellings built or retrofitted to apparently high energy efficienct standards show a performance gap when actually occupied largely due to occupant energy using and especially ventilation practices. The idea is to seperate these processes and use the parallel local carbon tax system to incentivise lower emissions from both.

Of course we need to be careful. A goal of reducing dwelling fabric emissions could be met by switching to all-electric heating and buying electricity from a purely renewable retailer. You can then use as much energy as you can afford - there will be no additional fabric-based _or_ occupant-based tax to pay. In this sense this could be an entirely avoidable tax. But maybe that is what we want... provided the grid can handle it.

Naturally in the long run such a system is unsustainable. Just as vehicle excise linked to engine emissions will generate less and less revenue over time as engines become cleaner and cleaner, so we would hope that our local carbon taxes would also tend to zero. In this case local authorities would need to evolve the system in such a way as to preserve revenue while still maintaining downward pressure on dwelling based emissions. They could return to some other form of progressive local income tax for example.

In the remainder of this paper we explore a number of ways of calculating both tax rates under a range of scenarios. These are:

 * revenue neutral - it generates the same revenue as the council tax did but puts downward pressure on emissons
 * revenue positive - it generates more revenue than the council tax did so that the 'surplus' can be recycled into energy efficiency and/or low emissions heat interventions while also putting downward pressure on emissons

An over-riding principle is that those at the lower end of the income distribution should be _no worse_ off and preferably better off than they were under the council tax. This may be tricky to model given the council tax rebate system. However, since energy consumption as a percentage of total expenditure declines with income (poor people pay proportionally more) but absolute energy consumption and emissions increase with income, there is clear scope to use tax revenues collected from 'high' emitters to support low income emissions transitions. 

We could assume that higher income higher emitters would have the capital to address their emissions but this may not be the case. They may also have sufficient income not to have to care about 'paying' for their emissions. The fact that the carbon tax rate is not entirely correlated with ability to pay at an individual level (inefficient homes running on fossil fuels are not only the preserve of the very rich) means there may be little incentive for very high income households to change. In this case we may need an additional approach such as a 'stamp duty' * emissions multiplier that is paid on the purchase of properties worth over a certain threshold. This would act to penalise those who had not bothered to invest since their purchasor would drive the price down (they would be about to take a tax hit). Clearly a very expensive house which has zero emissions (as above) would attract a zero tax charge. It might even significantly drive down the value of high emissions properties. Again, this may be what we want but if so it would significantly impact the asset values of people in larger, older and higher emissions homes - some of whom are not well off.

Finally, making the tax charge a dwelling and household level charge means that there is an incentive to increase occupant density since the cost is shared. We know that economies of scale are substantial for energy - the amount of energy used does not increase linearly with occupancy. Reducing single occupancy and incentivising multi-occupancy homes therefore decreases per capita emissions and also decreases total emissions. This could be a potential positive spill-over effect of the system we propose and _might_ align with the Governments proposed changes to the permitted development rights provided they are used to increase occupancy and not just increase unoccupied but heated space!

>NB: on vs off gas implications? Off gas = rural so usually oil. What about wood?

# Modelling the tax

In order to explore the revenue and tax load implications of these ideas we ideally need a dataset which links:

 * current council tax paid
 * estimated or actual annual space heating energy input, cost and emissions. Issues: identifying actual emissons from electricity depends on retailer & tariff; same for gas (e.g. green gas/biomethane offerings)
 * estimated or actual annual non-space heating energy input, cost and emissions. Issues: as above?
 * household income
 * household demographics (as the council tax rebate of 25% appiles to single adult households)
 * benefits status (?)

for each dwelling in all local authorities. We could then calculate the council and carbon tax charges per dwelling and see what happens under our different scenarios.

Unfortunately no such dataset exists.

However there are a number of ways of getting close:

 * EPC data: provides an estimate of kWh/m2 (a measure of energy input) and CO2e as a basis for the EPC banding. We could use the kWh/m2 value but this reduce the charge for large houses with big emissions simply due to size. We do not want that since it is the absolute value of emissions that really matters here. So we would use the kWh value instead. There are [a number of reasons](https://www.passivhaustrust.org.uk/guidance_detail.php?gId=44) why we would _not_ want to use the CO2e or EPC banding as the basis for our calculation, not least that it assumes a fixed and outdated carbon intensity for electricity. Unfortunately EPC data does not tell us about actual occupant-driven energy consumption. This would have to be estimated on the basis of very few sensible co-variates. EPCs are also only available on dwellings that have been sold since XXX or are currently rented. This excludes a sub-set of properties which are probably older and less energy efficient.
 * SAVE data: this sample of 4,000+ households from the Solent region has neither EPC or gas consumption data
 * NEED anonymised sample data: XX check XX
 * SERL smart meter data: this has all (or nearly all) of the attributes we need but 1) is for a sample of the population and 2) will not have complete EPC data since dwellings that are not rented or have not been recently sold will tend not to have an EPC.

## EPC-based models

Partial coverage, no household attributes so no distributional analysis

## NEED-based models

?

## SERL-based models

Data: https://beta.ukdataservice.ac.uk/datacatalogue/studies/study?id=8666#!/documentation

No income just has proxies:

 * Household level:
   * C3: Thinking about the working situation of each member of your household aged 16 and over, including you, how many would you say fall into each category below?
   * C4: Including you, how many people in your household hold a degree (e.g. BA, BSc) or higher qualification (e.g. MA, PhD, PGCE)?
 * Individual respondent:
   * D3: Which best describes your current employment
situation?
   * D4: How well would you say you yourself are managing financially these days? Would you say you are ...


## Summary

# Could this be done?

## Politically?

As we understand it local authorities can set council tax rates to 0 without triggering a referendum! But can they create a new local tax system of the kind we propose to replace it? Would it need new legislation? Or could it be created from a process that already exists? And if they then had to resurrect the Concil Tax to recover declining carbon tax revenue, would that automaticallly trigger a referendum?!

Perhaps more interestingly if a strongly 'green' local authority put a local tax system based on this approach to a local referendum with clear calculations of its effects for different social groups, would it be approved? From a purely rational self-interest persepctive it should if the majority would be better off because the bulk of the tax charge might fall on the higher emitters...

## Practically?

How would a local authority collect the data it needs at the dwelling level? Could it:

 * mandate full EPCs on all dwellings? Or charge a penalising rate to those that do not have them (they are not expensive to procure)
 * model likely consumption levels & emissions for each dwelling and so incentivise those whose emissons are actually lower to agree to the annual energy consumption being collected from their smart meters? But what to do about those who are higher?
 * mandate the collection of annual energy input data from the smart meter system for all dwellings, in much the same way that it is mandatory to declare income for tax purposes? The smart meter data includes tariff (XX check XX) and so carbon intensity (XX check XX)

# Should this be done?

Why not?

# Playing games

Inevitably any system that can be gamed for gain will be. Examples might include:

 * ?
 
We would need to think carefully how to structure the system to avoid this.

\newpage

# Background data and boundary files
We will use a number of datasets to analyse the patterns of emissions. Some of these are in the repo as they are public access, others are not (or too large).

## Boundaries

MSOA - use pre-created boundary files

```{r loadMSOA}

message ("Loading Solent MSOA boundaries from file")
boundaries <- list()
boundaries$msoa_solent <- sf::read_sf(here::here("data", "boundaries", "MSOA", "msoa_solent.shp"))
message("Rows of data: ", nrow(boundaries$msoa_solent))

message("Selecting Southampton")
# can't use function as sf not a data.table
boundaries$msoa_soton <- filter(boundaries$msoa_solent, LAD11NM == "Southampton")
message("Rows of data: ", nrow(boundaries$msoa_soton))
```

Check with a map...

```{r simpleMSOAMap, fig.cap = "MSOA check map (shows MSOA and LA names when clicked"}

st_coord_sys <- sf::st_crs(boundaries$msoa_soton) # check coord system
message("Boundary data co-ord system: ", st_coord_sys$epsg)
# if required transform current coord system to EPSG: 4326 (is what leaflet wants - good)
if(st_coord_sys$epsg != 4326){
 boundaries$msoa_soton_leaflet <- st_transform(boundaries$msoa_soton, "+proj=longlat +datum=WGS84")
}


leaflet(boundaries$msoa_soton_leaflet) %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addPolygons(fillOpacity = 0.2, 
              weight = 1.5, 
              popup = ~(paste0("MSOA: " ,MSOA11NM,
                      "<br> LA: ", LAD11NM)
                      ), # popups clicked
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                fillOpacity = 0.7,
                bringToFront = TRUE))

```

LSOA

```{r loadLSOA}
message ("Loading Solent LSOA boundaries from file")
boundaries <- list()
boundaries$lsoa_solent <- sf::read_sf(here::here("data", "boundaries", "LSOA", "lsoa_solent.shp"))
message("Rows of data: ", nrow(boundaries$lsoa_solent))

message("Loading LSOA look-up table with useful labels")
data <- list()
data$lsoa_lookup <- data.table::fread(here::here("data", "LSOA_lookup_solent.csv.gz"))

message("Selecting Southampton")
# can't use function as sf not a data.table
boundaries$lsoa_soton <- filter(boundaries$lsoa_solent, LAD11NM == "Southampton")
message("Rows of data: ", nrow(boundaries$lsoa_soton))
```

Check with a map...

```{r simpleLSOAMap, fig.cap = "LSOA check map (shows LSOA, MSOA and ward names when clicked"}

st_coord_sys <- sf::st_crs(boundaries$lsoa_soton) # check coord system
message("Boundary data co-ord system: ", st_coord_sys$epsg)
# if required transform current coord system to EPSG: 4326 (is what leaflet wants - good)
if(st_coord_sys$epsg != 4326){
 boundaries$lsoa_soton_leaflet <- st_transform(boundaries$lsoa_soton, "+proj=longlat +datum=WGS84")
}

boundaries$lsoa_soton_leaflet <- merge(boundaries$lsoa_soton_leaflet, data$lsoa_lookup[, .(LSOA11CD, WD20CD, WD20NM)],
                                       by = "LSOA11CD")

leaflet(boundaries$lsoa_soton_leaflet) %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addPolygons(fillOpacity = 0.2, 
              weight = 1.5, 
              popup = ~(paste0("LSOA: ",LSOA11NM,
                               "<br> MSOA: " , MSOA11NM,
                               "<br> Ward: ", WD20NM,
                               "<br> LA: ", LAD11NM)
                      ), # popups clicked
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                fillOpacity = 0.7,
                bringToFront = TRUE))

```


## IMD 2019

Labeled as 2019 but actually 2018 data. Source: https://www.gov.uk/government/statistics/english-indices-of-deprivation-2019

```{r loadIMD2019}
data$lsoa_imd2019 <- data.table::fread(here::here("data", "LSOA_Indices_of_Multiple_Deprivation_2019.csv.gz")
                                  )
data$lsoa_imd2019[, LAD11NM := LADnm]
data$lsoa_imd2019[, IMD_Decile_label := ifelse(IMD_Decile == 1, "1 (10% most deprived)",IMD_Decile)]
data$lsoa_imd2019[, IMD_Decile_label := ifelse(IMD_Decile == 10, "10 (10% least deprived)",IMD_Decile_label)]

data$lsoa_imd2019[, IMD_Decile_label := factor(IMD_Decile_label, levels = c("1 (10% most deprived)","2","3","4","5","6","7","8","9","10 (10% least deprived)"))]
table(data$lsoa_imd2019$IMD_Decile_label)                               

data$lsoa_imd2019_soton <- getSoton(data$lsoa_imd2019)
nrow(data$lsoa_imd2019_soton)
```

These are LSOA level deprivation indices. Decile is the English & Welsh decile:

 * 1 = 10% most deprived LSOAs in England & Wales;
 * 10 = 10% least deprived LSOA in England & Wales.

```{r imdLSOAMap, fig.cap = "LSOA IMD map (shows LSOA, MSOA, ward names and IMD decile when clicked"}

boundaries$lsoa_soton_leaflet <- merge(boundaries$lsoa_soton_leaflet, data$lsoa_imd2019_soton[, .(LSOA11CD= lsoa11cd, IMDScore, IMD_Decile,IMD_Decile_label)],
                                       by = "LSOA11CD")

colCats <- colorNumeric("Reds", boundaries$lsoa_soton_leaflet$IMDScore, n = 9)

leaflet(boundaries$lsoa_soton_leaflet) %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addPolygons(color = ~colCats(IMDScore),
              fillOpacity = 0.6, 
              weight = 1.5, 
              popup = ~(paste0("LSOA: ",LSOA11NM,
                               "<br> MSOA: " , MSOA11NM,
                               "<br> Ward: ", WD20NM,
                               "<br> LA: ", LAD11NM,
                               "<br> IMD decile: ",IMD_Decile )
                      ), # popups clicked
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                fillOpacity = 0.8,
                bringToFront = TRUE))

```

## CREDS place-based emmissions estimates

See https://www.creds.ac.uk/why-we-built-a-place-based-carbon-calculator/

"The highest carbon areas have an average per person footprint more than eight times larger than the lowest carbon areas."

"We are not effectively targeting decarbonisation policies in high carbon areas. For example, the recently collapsed Green Homes Grants scheme provided a grant to cover 66% of the cost (up to £5,000) of retrofitting homes.  For people claiming certain benefits, the cap was raised to 100% and £10,000. But the calculator shows that the big polluters are the large homes in very wealthy areas. In these neighbourhoods, the issue is not affordability but motivation. For high income households, energy costs are a small proportion of their expenditure and so the cost savings for retrofitting their home are inconsequential. As there are no policy “sticks” to incentivise action in the collective interest it is unsurprising that high carbon neighbourhoods have not prioritised decarbonisation."

Source: https://www.carbon.place/

Notes:

 * Emissions are presented as per capita...
 * Appears to be based on residential/citizen emissions only - does not appear to include commercial/manufacturing/land use etc

```{r loadCREDSpbcc}
data$lsoa_creds_pbcc <- data.table::fread(here::here("data", "LSOA_CREDS_PBCC_data.csv.gz"))
# % of total emissions due to gas & elec & other heat
data$lsoa_creds_pbcc[, energy_pc := 100*((elec_percap_2018 + gas_percap_2018 + other_heat_percap_2011)/total_kgco2e_percap)]
# % of household (spaces?) with mainly elec
data$lsoa_creds_pbcc[, pc_Heating_Electric := 100*(pHeating_Electric/(pHeating_None + pHeating_Gas + pHeating_Electric + pHeating_Oil + pHeating_Solid+ pHeating_Other))]

data$lsoa_creds_pbcc[, LAD11NM := LAD17NM] # for matching - beware name changes

#summary(data$lsoa_creds_pbcc$pc_Heating_Electric)
```

## Fuel poverty
2019 estimates

Source: https://www.gov.uk/government/statistics/sub-regional-fuel-poverty-data-2021


```{r loadBEISFP}
data$lsoa_beis_fp <- data.table::fread(here::here("data", "LSOA_Fuel_Poverty_2019.csv.gz"))
```

# Non-domestic carbon tax - examples

We can use the BEIS non-domestic gas & electricity data at MSOA level. Note that some use is non-allocated

## Gas

Load data

## Electricity

# Domestic carbon tax - examples

## Using the CREDS data

Case studies:

 * Annual carbon tax
 * Half-hourly (real time) carbon tax

BEIS/ETC Carbon ‘price’

 * 2020 - £21.93 https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/849276/Carbon__Penalty_Price_Determination_for_2020.pdf 

EU carbon ‘price’

 * September 2021: €60 (£51) https://tradingeconomics.com/eecxm:ind

BEIS Carbon ‘Value’ https://www.gov.uk/government/publications/valuing-greenhouse-gas-emissions-in-policy-appraisal/valuation-of-greenhouse-gas-emissions-for-policy-appraisal-and-evaluation#annex-1-carbon-values-in-2020-prices-per-tonne-of-co2

 * based on a Marginal Abatement Cost (MAC)
 * 2021: 
    * Low: £122/T
    * Central: £245/T
    * High: £367/T

Convert the per capita to totals and then use the number of electricity meters as a proxy for the number of dwellings

Ideally we'd have Census 2021 data but we don't have it yet. So instead we'll use the number of electricity meters (might be an over-estimate if a dwelling has 2...)

First check the n electricity meters logic...

```{r check_nElecMeters}
gasF <- here::here("data", "LSOA_GAS_2019.csv.gz")
gasDT <- data.table::fread(gasF)
gasDT[,LAD11NM := `Local Authority Name`]
gasDT[,LSOA11CD := `Lower Layer Super Output Area (LSOA) Code`]
soton_gas2019DT <- getSoton(gasDT)
setkey(soton_gas2019DT, LSOA11CD, LAD11NM)

elecF <- here::here("data", "LSOA_ELEC_2019.csv.gz")
elecDT <- data.table::fread(elecF)
elecDT[,LAD11NM := `Local Authority Name`]
elecDT[,LSOA11CD := `Lower Layer Super Output Area (LSOA) Code`]
soton_elec2019DT <- getSoton(elecDT)
setkey(soton_elec2019DT, LSOA11CD, LAD11NM)

energy_2019DT <- soton_elec2019DT[soton_gas2019DT]
energy_2019DT[, nGasMeters := `Number of consuming meters`]
energy_2019DT[, nElecMeters := `Total number of domestic electricity meters`]
setkey(energy_2019DT, LSOA11CD)

# get CREDS data (again) ----
soton_CREDS <- getSoton(data$lsoa_creds_pbcc[, .(LAD11NM, WD18NM, LSOA11CD = LSOA11, 
                                        CREDStotal_kgco2e_percap = total_kgco2e_percap,
                                        CREDSgas_percap_2018 = gas_percap_2018,
                                        CREDSelec_percap_2018 = elec_percap_2018,
                                        pop_2018, energy_pc, pc_Heating_Electric,
                                        epc_total, epc_newbuild, epc_A, epc_B,
                                        epc_C, epc_D, epc_E, epc_F, epc_G,
                                        epc_mainfuel_electric = mainfuel_electric)])

# calc totals
soton_CREDS[, CREDStotal_kgco2e := CREDStotal_kgco2e_percap * pop_2018]
soton_CREDS[, CREDSgas_kgco2e2018 := CREDSgas_percap_2018 * pop_2018]
soton_CREDS[, CREDSelec_kgco2e2018 := CREDSelec_percap_2018 * pop_2018]
soton_CREDS[, CREDSotherEnergy_kgco2e2011 := other_heat_percap_2011 * pop_2018]
soton_CREDS[, CREDSallHomeEnergy_kgco2e2011 := CREDSotherEnergy_kgco2e2011 + CREDSgas_kgco2e2018 + CREDSelec_kgco2e2018 + CREDSotherEnergy_kgco2e2011]
soton_CREDS[, CREDScar_kgco2e2018 := car_percap_2018 * pop_2018]
soton_CREDS[, CREDSvan_kgco2e2018 := van_percap_2018 * pop_2018]

setkey(soton_CREDS, LSOA11CD)
message("Soton LSOAs: ")
nrow(soton_CREDS)

# add IMD etc
lsoa_imd2019_soton <- data$lsoa_imd2019_soton
lsoa_imd2019_soton[, LSOA11CD := lsoa11cd]
setkey(lsoa_imd2019_soton, LSOA11CD)

soton_CREDS <- soton_CREDS[lsoa_imd2019_soton[, .(LSOA11CD, IMD_Decile, IMDScore, IMD_Decile_label)]] # reduced set of vars

soton_CREDS <- soton_CREDS[energy_2019DT]
```

```{r checkDwellingCounts}
p <- soton_CREDS[, .(BEIS_nGasMeters2019 = nGasMeters, 
                     BEIS_nElecMeters2019 = nElecMeters, 
                     CREDS_epc_total2019 = epc_total)]

pairs(p)
```
Seems sensible...

```{r impute_EPC_counts}
# CREDS data has counts - we know there are missing EPCs
message("N EPCs")
summary(soton_CREDS$epc_total)
message("N elec meters")
summary(soton_CREDS$nElecMeters)

# We will assume the distribution of EPCs across bands within LSOAs is unbiased
# So the % will be OK but the count will be wrong
soton_CREDS[, epc_A_pc := epc_A/epc_total]
soton_CREDS[, epc_B_pc := epc_B/epc_total]
soton_CREDS[, epc_C_pc := epc_C/epc_total]
soton_CREDS[, epc_D_pc := epc_D/epc_total]
soton_CREDS[, epc_E_pc := epc_E/epc_total]
soton_CREDS[, epc_F_pc := epc_F/epc_total]
soton_CREDS[, epc_G_pc := epc_G/epc_total]

soton_CREDS[, epc_A_imp := epc_A_pc * nElecMeters] # rebase using nElecMeters
soton_CREDS[, epc_B_imp := epc_B_pc * nElecMeters]
soton_CREDS[, epc_C_imp := epc_C_pc * nElecMeters]
soton_CREDS[, epc_D_imp := epc_D_pc * nElecMeters]
soton_CREDS[, epc_E_imp := epc_E_pc * nElecMeters]
soton_CREDS[, epc_F_imp := epc_F_pc * nElecMeters]
soton_CREDS[, epc_G_imp := epc_G_pc * nElecMeters]
```

Correlation between high % EPC F/G or A/B and deprivation?

```{r plotEPC_pc}
ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, y = epc_F_pc + epc_G_pc)) +
  geom_point() +
  geom_smooth()

ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, y = epc_A_pc + epc_B_pc)) +
  geom_point() +
  geom_smooth()
```

Now we need to convert the % to dwellings using the number of electricity meters (see above).

```{r plotEPC_impute}
ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, y = epc_F_imp + epc_G_imp)) +
  geom_point() +
  geom_smooth()

ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, y = epc_A_imp + epc_B_imp)) +
  geom_point() +
  geom_smooth()
```


Seems sensible...

### Per dwelling emissions

Redraw some of the original scatters using per dwelling instead of per capita

```{r estimatePerDwerllingEmissions}

soton_CREDS[, CREDStotal_kgco2e_pdw := CREDStotal_kgco2e/nElecMeters]
summary(soton_CREDS$CREDStotal_kgco2e_pdw/1000)

soton_CREDS[, CREDSgas_kgco2e2018_pdw := CREDSgas_kgco2e2018/nElecMeters]
summary(soton_CREDS$CREDSgas_kgco2e2018_pdw/1000)

soton_CREDS[, CREDSelec_kgco2e2018_pdw := CREDSelec_kgco2e2018/nElecMeters]
summary(soton_CREDS$CREDSelec_kgco2e2018_pdw/1000)

soton_CREDS[, CREDSenergy_kgco2e2018_pdw:= (CREDSelec_kgco2e2018/nElecMeters) + (CREDSgas_kgco2e2018/nElecMeters)]

```

```{r scatterIMDallCO2eperdw, fig.height = 5, fig.cap="Scatter of LSOA level all per dwelling emissions against IMD score - who emits?"}
message("Per dwelling T CO2e - all emissions")


ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, y = CREDStotal_kgco2e_pdw/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "IMD 2019 score",
       y = "Estimated total T CO2e/household (CREDS, 2021)")
ggplot2::ggsave(filename = here::here("plots/scatterIMD_CREDStotal_kgco2e_pdw.png"))

message("Correlation test (pwcorr)")
cor.test(soton_CREDS$IMDScore, soton_CREDS$CREDStotal_kgco2e_pdw)

t <- soton_CREDS[, .(LSOA11CD, WD18NM, All_Tco2e_per_dw = CREDStotal_kgco2e_pdw/1000)]

head(t[order(-All_Tco2e_per_dw)])

tail(t[order(-All_Tco2e_per_dw)])

sf <- merge(map_sf, t, by = "LSOA11CD")

colCats <- colorNumeric("Reds", t$All_Tco2e_per_dw, n = 9)

leaflet(sf) %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addPolygons(color = ~colCats(All_Tco2e_per_dw),
              fillOpacity = 0.6, 
              weight = 1.5, 
              popup = ~(paste0("LSOA: ",LSOA11NM,
                               "<br> Ward: ", WD20NM,
                               "<br> T CO2e/dwelling: ", dkUtils::tidyNum(round(All_Tco2e_per_dw)))
                      ), # popups clicked
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                fillOpacity = 0.8,
                bringToFront = TRUE))




```


```{r scatterIMDgasCO2eperdw, fig.height = 5, fig.cap="Scatter of LSOA level gas per dwelling emissions against IMD score - who emits?"}

message("Per dwelling T CO2e - gas emissions")


ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, y = CREDSgas_kgco2e2018_pdw/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "IMD 2019 score",
       y = "Estimated gas T CO2e/household (CREDS, 2021)")
ggplot2::ggsave(filename = here::here("plots/scatterIMD_CREDSgas_kgco2e2018_pdw.png"))

message("Correlation test (pwcorr)")
cor.test(soton_CREDS$IMDScore, soton_CREDS$CREDSgas_kgco2e2018_pdw)
```

```{r scatterIMDelecCO2eperdw, fig.height = 5, fig.cap="Scatter of LSOA level elec per dwelling emissions against IMD score - who emits?"}

message("Per dwelling T CO2e - elec emissions")

ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, y = (CREDSelec_kgco2e2018/nElecMeters)/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "IMD 2019 score",
       y = "Estimated electricity T CO2e/household (CREDS, 2021)")
ggplot2::ggsave(filename = here::here("plots/scatterIMD_CREDSelec_kgco2e2018_pdw.png"))

message("Correlation test (pwcorr)")
cor.test(soton_CREDS$IMDScore, soton_CREDS$CREDSelec_kgco2e2018_pdw)

```

```{r correlateAllandEnergyEmissions}

cor.test(soton_CREDS$CREDStotal_kgco2e_pdw, soton_CREDS$CREDSenergy_kgco2e2018_pdw)

ggplot2::ggplot(soton_CREDS, aes(x = CREDStotal_kgco2e_pdw/1000, 
                                 y = CREDSenergy_kgco2e2018_pdw/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Estimated total T CO2e/household (CREDS, 2021)",
       y = "Estimated energy T CO2e/household (CREDS, 2021)")
ggplot2::ggsave(filename = here::here("plots/scatterCREDStotal_kgco2e_pdw_CREDSenergy_kgco2e2018_pdw.png"))
```


### Estimate Levy

```{r estimateAnnualLevy}
# carbon costs
eu_ets <- 51
beis_l <- 122
beis_c <- 245
beis_h <- 367

soton_CREDS[, eu_ets_GBPtotal := CREDStotal_kgco2e/1000 * eu_ets] # £ in tonnes so /1000
soton_CREDS[, eu_ets_GBPtotal_perdw := eu_ets_GBPtotal/nElecMeters]

soton_CREDS[, beis_GBPtotal_l := CREDStotal_kgco2e/1000 * beis_l]
soton_CREDS[, beis_GBPtotal_l_perdw := beis_GBPtotal_l/nElecMeters]
soton_CREDS[, beis_GBPtotal_l_gas := CREDSgas_kgco2e2018/1000 * beis_l]
soton_CREDS[, beis_GBPtotal_l_elec := CREDSelec_kgco2e2018/1000 * beis_l]
soton_CREDS[, beis_GBPtotal_l_gas_perdw := beis_GBPtotal_l_gas/nElecMeters]
soton_CREDS[, beis_GBPtotal_l_elec_perdw := beis_GBPtotal_l_elec/nElecMeters]

soton_CREDS[, beis_GBPtotal_c := CREDStotal_kgco2e/1000 * beis_c]
soton_CREDS[, beis_GBPtotal_c_perdw := beis_GBPtotal_c/nElecMeters]
soton_CREDS[, beis_GBPtotal_c_gas := CREDSgas_kgco2e2018/1000 * beis_c]
soton_CREDS[, beis_GBPtotal_c_elec := CREDSelec_kgco2e2018/1000 * beis_c]
soton_CREDS[, beis_GBPtotal_c_gas_perdw := beis_GBPtotal_c_gas/nElecMeters]
soton_CREDS[, beis_GBPtotal_c_elec_perdw := beis_GBPtotal_c_elec/nElecMeters]

soton_CREDS[, beis_GBPtotal_h := CREDStotal_kgco2e/1000 * beis_h]
soton_CREDS[, beis_GBPtotal_h_gas := CREDSgas_kgco2e2018/1000 * beis_h]
soton_CREDS[, beis_GBPtotal_h_elec := CREDSelec_kgco2e2018/1000 * beis_h]
soton_CREDS[, beis_GBPtotal_h_perdw := beis_GBPtotal_h/nElecMeters]
soton_CREDS[, beis_GBPtotal_h_gas_perdw := beis_GBPtotal_h_gas/nElecMeters]
soton_CREDS[, beis_GBPtotal_h_elec_perdw := beis_GBPtotal_h_elec/nElecMeters]

soton_CREDS[, beis_GBPtotal_c_energy := beis_GBPtotal_c_gas + beis_GBPtotal_c_elec]
soton_CREDS[, beis_GBPtotal_c_energy_perdw := beis_GBPtotal_c_gas_perdw + beis_GBPtotal_c_elec_perdw]
```

```{r totalTOC2e}
t <- soton_CREDS[, .(sum_TCO2e = sum(CREDStotal_kgco2e)/1000,
            sum_TCO2e_gas = sum(CREDSgas_kgco2e2018)/1000,
            sum_TCO2e_elec = sum(CREDSelec_kgco2e2018)/1000)]
t
```

```{r GBP_ets}
t <- soton_CREDS[, .(eu_ets_GBPtotal = sum(eu_ets_GBPtotal),
            mean_eu_ets_GBPtotal_perdw = mean(eu_ets_GBPtotal_perdw))]

t
```

```{r GBP_beis_l}
t <- soton_CREDS[, .(beis_GBPtotal_l = sum(beis_GBPtotal_l),
                     beis_GBPtotal_l_gas = sum(beis_GBPtotal_l_gas),
                     beis_GBPtotal_l_elec = sum(beis_GBPtotal_l_elec))]

t
```

```{r GBP_beis_c}
t <- soton_CREDS[, .(beis_GBPtotal_c = sum(beis_GBPtotal_c),
                     beis_total_c_gas = sum(beis_GBPtotal_c_gas),
                     beis_GBPtotal_c_elec = sum(beis_GBPtotal_c_elec))]

t
```

```{r GBP_beis_h}
t <- soton_CREDS[, .(beis_GBPtotal_h = sum(beis_GBPtotal_h),
                     beis_total_h_gas = sum(beis_GBPtotal_h_gas),
                     beis_GBPtotal_h_elec = sum(beis_GBPtotal_h_elec))]

t
```

```{r GBP_beis_perdw}
t <- soton_CREDS[, .(beis_GBPtotal_l_perdw = mean(beis_GBPtotal_l_perdw),
                     beis_GBPtotal_l_gas_perdw = mean(beis_GBPtotal_l_gas_perdw),
                     beis_GBPtotal_l_elec_perdw = mean(beis_GBPtotal_l_elec_perdw))]

t

t <- soton_CREDS[, .(beis_GBPtotal_c_perdw = mean(beis_GBPtotal_c_perdw),
                     beis_GBPtotal_c_gas_perdw = mean(beis_GBPtotal_c_gas_perdw),
                     beis_GBPtotal_c_elec_perdw = mean(beis_GBPtotal_c_elec_perdw),
                     beis_GBPtotal_c_energy_perdw = mean(beis_GBPtotal_c_energy_perdw))]

t

t <- soton_CREDS[, .(beis_GBPtotal_h_perdw = mean(beis_GBPtotal_h_perdw),
                     beis_GBPtotal_h_gas_perdw = mean(beis_GBPtotal_h_gas_perdw),
                     beis_GBPtotal_h_elec_perdw = mean(beis_GBPtotal_h_elec_perdw))]

t
```

#### Plotting the cost of carbon

##### All emissions

The cost of carbon: ETS Figure \@ref(fig:whoWinsETS)

```{r whoWinsETS, fig.cap = "£k per LSOA incurred using ETS carbon price"}


allEmissionsCap <- "All emissions (CREDS)"
  
ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, 
                            y = eu_ets_GBPtotal/1000)) +
  geom_point(aes(colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "ETS 'carbon value' £k",
       caption = allEmissionsCap)
```

The cost of carbon: BEIS central cost Figure \@ref(fig:whoWinsBEISc)

```{r whoWinsBEISc, fig.cap = "£k per LSOA incurred using BEIS central carbon price"}
ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, 
                            y = beis_GBPtotal_c/1000)) +
  geom_point(aes(colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon value' £k",
       caption = allEmissionsCap)
ggplot2::ggsave(filename = here::here("plots/whoWins_beis_GBPtotal_c.png"))

ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_perdw)) +
  geom_point(aes(colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon value' £ per dwelling",
       caption = allEmissionsCap)
ggplot2::ggsave(filename = here::here("plots/whoWins_beis_GBPtotal_c_perdw.png"))
summary(soton_CREDS$beis_GBPtotal_c_perdw)

t <- soton_CREDS[, .(LSOA11CD, WD18NM, beis_GBPtotal_c, beis_GBPtotal_c_perdw)]

head(t[order(-beis_GBPtotal_c_perdw)])

tail(t[order(-beis_GBPtotal_c_perdw)])
```


##### Gas emissions

The cost of carbon: BEIS lower cost Figure \@ref(fig:whoWinsBEIScGas)

```{r whoWinsBEIScGas, fig.height=5, fig.cap = "£k per LSOA incurred via gas using BEIS central carbon price"}
gasEmissionsCap <- "Emissions due to gas"

ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_gas/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon value' £k",
       caption = gasEmissionsCap)
ggplot2::ggsave(filename = here::here("plots/whoWinsBEIS_c_gas_total.png"))

ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_gas_perdw)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon value' £ per dwelling",
       caption = gasEmissionsCap)
ggplot2::ggsave(filename = here::here("plots/whoWinsBEIS_c_gas_perdw.png"))

summary(soton_CREDS$beis_GBPtotal_c_gas_perdw)
```


##### Electricity emissions

The cost of carbon: BEIS central cost Figure \@ref(fig:whoWinsBEIScElec)

```{r whoWinsBEIScElec, fig.height=5, fig.cap = "£k per LSOA incurred via electricity using BEIS central carbon price"}

elecEmissionsCap <- "Emissions due to electricity"

ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_elec/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon value' £k",
       caption = elecEmissionsCap)
ggplot2::ggsave(filename = here::here("plots/whoWinsBEIS_c_elec_total.png"))

ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_elec_perdw)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon value' £ per dwelling",
       caption = elecEmissionsCap)
ggplot2::ggsave(filename = here::here("plots/whoWinsBEIS_c_elec_perdw.png"))

summary(soton_CREDS$beis_GBPtotal_c_elec_perdw)
```

##### Energy emissions

The cost of carbon: BEIS lower cost Figure \@ref(fig:whoWinsBEIScEnergy) - elec + gas

```{r whoWinsBEIScEnergy, fig.height=5, fig.cap = "£k per LSOA incurred via electricity using BEIS central carbon price"}

elecEmissionsCap <- "Emissions due to electricity & gas"


ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_energy/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon value' £k",
       caption = elecEmissionsCap)
ggplot2::ggsave(filename = here::here("plots/whoWinsBEIS_c_energy_total.png"))

ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_energy_perdw)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon value' £ per dwelling",
       caption = elecEmissionsCap)
ggplot2::ggsave(filename = here::here("plots/whoWinsBEIS_c_energy_perdw.png"))

summary(soton_CREDS$beis_GBPtotal_c_energy_perdw)
```

### Estimate retofit costs

fromAE <- 13300
fromFG <- 26800

Excludes EPC A, B & C (assumes no need to upgrade)

```{r estRetrofitCosts}

fromAE <- 13300
fromFG <- 26800
soton_CREDS[, retrofitDE := (epc_D_imp + epc_E_imp) * fromAE] # exclude epc_A_imp
soton_CREDS[, retrofitFG := (epc_F_imp + epc_G_imp) * fromFG]
soton_CREDS[, sumDE := (epc_D_imp + epc_E_imp)]
soton_CREDS[, sumFG := (epc_F_imp + epc_G_imp)]

soton_CREDS[, retrofitSum := retrofitDE + retrofitFG]
soton_CREDS[, retrofitMeanPerDw := retrofitSum/(epc_D_imp + epc_E_imp + epc_F_imp + epc_G_imp)]

message("To retrofit D-E")
sum(soton_CREDS$retrofitDE)
message("Number of dwellings: ", round(sum(soton_CREDS$sumDE)))

message("To retrofit F-G")
sum(soton_CREDS$retrofitFG)
message("Number of dwellings: ", round(sum(soton_CREDS$sumFG)))

message("To retrofit D-G")
sum(soton_CREDS$retrofitSum)

message("To retrofit D-G (mean per dwelling)")
mean(soton_CREDS$retrofitMeanPerDw)

soton_CREDS[, .(meanPerLSOA = mean(retrofitSum))]

ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, y = retrofitSum/1000000)) +
  geom_point(aes(colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Total retrofit cost (£M)")
ggplot2::ggsave(filename = here::here("plots", "sotonLSOA_retrofitSum.png"))

ggplot2::ggplot(soton_CREDS, aes(x = IMD_Decile_label, 
                            y = retrofitSum/1000000,
                            colour = IMD_Decile_label)) +
  geom_boxplot() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Total retrofit cost (£M)")

ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, y = retrofitMeanPerDw)) +
  geom_point(aes(colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Mean retrofit cost per dwelling (£)")
ggplot2::ggsave(filename = here::here("plots", "sotonLSOA_retrofit_per_dwelling.png"))

ggplot2::ggplot(soton_CREDS, aes(x = IMD_Decile_label, y = retrofitMeanPerDw)) +
  geom_boxplot() +
  labs(y = "Mean retrofit cost per dwelling (£)")
```

Map cost

```{r credsLSOAMapRetrofitCost, fig.cap = "LSOA retrofit costs (upgrade EPC C to F)"}

soton_CREDS_sf <- merge(map_sf, soton_CREDS, by = "LSOA11CD")

colCats <- colorNumeric("Reds", soton_CREDS_sf$retrofitSum, n = 9)

leaflet(soton_CREDS_sf) %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addPolygons(color = ~colCats(retrofitSum),
              fillOpacity = 0.6, 
              weight = 1.5, 
              popup = ~(paste0("LSOA: ",LSOA11NM,
                               "<br> Ward: ", WD20NM,
                               "<br> % EPC A-C: ",round(100*(epc_A_pc + epc_B_pc + epc_C_pc)), " %",
                               "<br> % EPC D-E: ",round(100*(epc_D_pc + epc_E_pc)), " %", # it's actually a proportion not a %
                               "<br> % EPC F-G: ",round(100*(epc_F_pc + epc_G_pc)), " %",
                               "<br> Retrofit cost: £",round(retrofitSum/1000000,2), " M")
                      ), # popups clicked
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                fillOpacity = 0.8,
                bringToFront = TRUE))





t <- soton_CREDS[, .(LSOA11CD, WD18NM, # NB not WD20NM
                epc_pc_A_C = 100*(epc_A_pc + epc_B_pc + epc_C_pc),
                retrofitSum)]

head(t[order(retrofitSum)])

head(t[order(-retrofitSum)])
```

### Compare levy with costs

```{r co2eToRettofitTotal, fig.height=5}
ggplot2::ggplot(soton_CREDS, aes(x = beis_GBPtotal_c/1000, y = retrofitSum/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Total estimated levy (all emissions, £k)",
       y = "Dwelling retrofit cost (£k)")

ggplot2::ggsave(filename = here::here("plots/whoWins_RetrofitCost_beis_GBPtotal_c.png"))

ggplot2::ggplot(soton_CREDS, aes(x = (beis_GBPtotal_c_gas + beis_GBPtotal_c_elec)/1000, y = retrofitSum/1000)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Total estimated levy (energy, £k)",
       y = "Dwelling retrofit cost (£k)")

ggplot2::ggsave(filename = here::here("plots/whoWins_RetrofitCost_beis_GBPtotal_c_energy.png"))
```

Repeat per dwelling

```{r co2eToRettofitPerDwelling, fig.height=5}
ggplot2::ggplot(soton_CREDS, 
                aes(x = beis_GBPtotal_c_perdw, y = retrofitMeanPerDw)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Mean emissions levy (all emissions, £)",
       y = "Mean dwelling retrofit cost (£)")
ggplot2::ggsave(filename = here::here("plots/whoWins_RetrofitCost_beis_GBPtotal_c_perdw.png"))

ggplot2::ggplot(soton_CREDS, aes(x = (beis_GBPtotal_c_gas_perdw + beis_GBPtotal_c_elec_perdw), y = retrofitMeanPerDw)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Mean emissions levy per dwelling due to energy (£)",
       y = "Mean dwelling retrofit cost (£k)")

ggplot2::ggsave(filename = here::here("plots/whoWins_RetrofitCost_beis_GBPtotal_c_energy_perdw.png"))
```


### Years to pay...

```{r allLevyPayOff, fig.height=5}

soton_CREDS[, yearsRequiredToPayRetrofit_beis_GBPtotal_c_perdw := retrofitMeanPerDw/beis_GBPtotal_c_perdw]
summary(soton_CREDS$yearsRequiredToPayRetrofit_beis_GBPtotal_c_perdw)

ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, 
                            y = yearsRequiredToPayRetrofit_beis_GBPtotal_c_perdw)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  geom_hline(yintercept = median(soton_CREDS$yearsRequiredToPayRetrofit_beis_GBPtotal_c_perdw), colour = "orange") +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Years to pay off",
       caption = "BEIS central carbon value, all emissions levy")
ggplot2::ggsave(filename = here::here("plots/whoWins_yearsRequiredToPayRetrofit_beis_GBPtotal_c_perdw.png"))

```

```{r energyLevyPayOff, fig.height=5}
soton_CREDS[, yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw := retrofitMeanPerDw/(beis_GBPtotal_c_gas_perdw + beis_GBPtotal_c_elec_perdw)]

summary(soton_CREDS$yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw)

ggplot2::ggplot(soton_CREDS, aes(x = IMDScore, 
                            y = yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw)) +
  geom_point(aes(size = pc_Heating_Electric, colour = IMD_Decile_label)) +
  geom_smooth() +
  geom_hline(yintercept = median(soton_CREDS$yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw), colour = "orange") +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Years to pay off",
       caption = "BEIS central carbon value, gas emissions levy\n(excludes LSOA with 0 gas)")
ggplot2::ggsave(filename = here::here("plots/whoWins_yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw.png"))

```


```{r transferVisAll}
plotDT <- soton_CREDS[, .(LSOA11CD, beis_GBPtotal_c, beis_GBPtotal_c_elec, beis_GBPtotal_c_gas, retrofitSum, WD18NM, IMDScore)]
share_Y1_total_c <- sum(plotDT$beis_GBPtotal_c)/uniqueN(plotDT$LSOA11CD) # divide the year 1 levy equally
share_Y1_energy_c <- (sum(plotDT$beis_GBPtotal_c_elec) + sum(plotDT$beis_GBPtotal_c_gas))/uniqueN(plotDT$LSOA11CD) # divide the year 1 levy equally


plotDT[, surplusY1_total_c := share_Y1_total_c - retrofitSum] # equal share

plotDT[, surplusY1_energy_c := share_Y1_energy_c - retrofitSum]

ggplot2::ggplot(plotDT, aes(x = reorder(LSOA11CD, -retrofitSum), fill = retrofitSum/1000000)) +
  geom_col(aes(y = retrofitSum/1000000)) +
  geom_point(aes(y = share_Y1_total_c/1000000, colour = "Levy Year 1")) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  scale_fill_continuous(name = "Retrofit cost (£M)") +
  scale_color_discrete(name = "Levy Year 1 (£M)") +
  facet_wrap(. ~ WD18NM, scales="free_x") +
  labs(x = "LSOAs (ordered by retrofit cost)",
       y = "£M",
       caption = "BEIS central carbon value, all emissions levy")

ggplot2::ggsave(filename = here::here("plots/transferVis_allEmissions_c.png"))

ggplot2::ggplot(plotDT, aes(x = reorder(LSOA11CD, -retrofitSum), colour = WD18NM,
                            y = surplusY1_total_c/1000000)) +
                  geom_point() +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  geom_hline(yintercept = 0, colour = "red") +
  scale_color_discrete(name = "Ward") +
  labs(x = "LSOAs (ordered by retrofit cost)",
       y = "Year 1 surplus (£M)",
       caption = "BEIS central carbon value, all emissions levy")
ggplot2::ggsave(filename = here::here("plots/surplusVis_allEmissions_c.png"))
```

```{r transferVisEnergy}
ggplot2::ggplot(plotDT, aes(x = reorder(LSOA11CD, -retrofitSum), fill = retrofitSum/1000000)) +
  geom_col(aes(y = retrofitSum/1000000)) +
  geom_point(aes(y = share_Y1_energy_c/1000000, colour = "Levy Year 1")) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  scale_fill_continuous(name = "Retrofit cost (£M)") +
  scale_color_discrete(name = "Levy Year 1 (£M)") +
  facet_wrap(. ~ WD18NM, scales="free_x") +
  labs(x = "LSOAs (ordered by retrofit cost)",
       y = "£M",
       caption = "BEIS central carbon value, energy emissions levy")

ggplot2::ggsave(filename = here::here("plots/transferVis_energyEmissions_c.png"))

ggplot2::ggplot(plotDT, aes(x = reorder(LSOA11CD, -retrofitSum), colour = WD18NM,
                            y = surplusY1_energy_c/1000000)) +
                  geom_point() +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  geom_hline(yintercept = 0, colour = "red") +
  scale_color_discrete(name = "Ward") +
  labs(x = "LSOAs (ordered by retrofit cost)",
       y = "Year 1 surplus (£M)",
       caption = "BEIS central carbon value, energy emissions levy")
ggplot2::ggsave(filename = here::here("plots/surplusVis_energyEmissions_c.png"))

```
What happens in Year 2 totally depends on the rate of upgrades...

## Based on gas & electricity data for 2018

For comparison with the CREDS PBCC

### Domestic gas
This uses the BEIS LSOA level electricity & gas data. Note that the gas data is weather corrected.

Use [BEIS 2019 conversion factors](https://www.gov.uk/government/publications/greenhouse-gas-reporting-conversion-factors-2018): 

```{r setEFgas}
co2eKg <- list()
co2eKg$gas_use <- 0.18396
co2eKg$gas_wtt <- 0.02557
```

 *   `r co2eKg$gas_use` kg CO2e/kWh - emissions in use
 *   `r co2eKg$gas_wtt` kg CO2e/kWh (WTT - i.e. upstream processing & distribution)

```{r loadLSOAGas}
gasF <- here::here("data", "LSOA_GAS_2018.csv.gz")
gasDT <- data.table::fread(gasF)
gasDT[,LAD11NM := `Local Authority Name`]
sotonGasDT <- getSoton(gasDT)

sotonGasDT[, co2eKg_gas_use := `Consumption (kWh)` * co2eKg$gas_use]
sotonGasDT[, co2eKg_gas_wtt := `Consumption (kWh)` * co2eKg$gas_wtt]
sotonGasDT[, co2eKg_gas_total := co2eKg_gas_use + co2eKg_gas_wtt]

message("N LSOAs = ", nrow(sotonGasDT))
message("Check LA")
sotonGasDT[, .(nLSOAs = .N,
               totalMWh = sum(`Consumption (kWh)`/1000),
               totalCo2eT_use = sum(co2eKg_gas_use/1000),
               totalCo2eT_wtt = sum(co2eKg_gas_wtt/1000),
               totalCo2eT = sum(co2eKg_gas_total/1000)), keyby = .(LAD11NM)]
s <- sum(sotonGasDT$co2eKg_gas_total/1000)
message("T CO2e from domestic gas in 2018: ", tidyNum(sum(sotonGasDT$co2eKg_gas_total/1000)))

sotonTotalsTCO2e$BEIS_gas <- s
message("Comparing sources")
as.data.table(sotonTotalsTCO2e)
```

Map the carbon footprint of domestic gas use in Southampton

```{r mapGasUse}
```

# R environment

## R packages used

* base R [@baseR]
* bookdown [@bookdown]
* data.table [@data.table]
* ggplot2 [@ggplot2]
* kableExtra [@kableExtra]
* knitr [@knitr]
* rmarkdown [@rmarkdown]
* skimr [@skimr]

## Session info


# Data Tables

I don't know if this will work...

```{r skimTables}
# tables <- names(data)
# for(t in tables){
#   print(lapply(tables, FUN(x) skimr::skim(data$eval(t)))
# }
message("Doesn't")
```

# References

