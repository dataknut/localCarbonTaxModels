---
params:
  subtitle: ""
  title: ""
  authors: ""
  filter: ""
  rmdFile: ""
title: '`r params$title`'
subtitle: '`r params$subtitle`'
author: '`r params$authors`'
date: 'Last run at: `r Sys.time()`'
output:
  bookdown::html_document2:
    self_contained: yes
    fig_caption: yes
    code_folding: hide
    number_sections: yes
    toc: yes
    toc_depth: 4
    toc_float: TRUE
  bookdown::word_document2:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 4
    fig_width: 5
  bookdown::pdf_document2:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 4
bibliography: '`r path.expand("~/bibliography.bib")`'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```


```{r rmdSetup, include=FALSE}

# Libraries used only in rmd ----
myLibs <- c("flextable",
            "ggplot2",
            "here",
            "lubridate",
            "skimr",
            "viridisLite")

dkUtils::loadLibraries(myLibs)

# Parameters ----

rmdParams <- list()

if(params$title == ""){
  message("In notebook mode")
  message("Make sure you run the data creation parts of makefile_emissionsLevyLSOA.R first")
  rmdParams$filter <- "Southampton"
  capFilter <- paste0("LSOAs: City of Southampton") # for plots
  reportLink <- paste0("https://dataknut.github.io/localCarbonTaxModels/simulating_local_emissions_levy_template_Southampton.html")
} else {
  # we're in report-run mode
  rmdParams$filter <- params$filter
  capFilter <- paste0("LSOAs: ", rmdParams$filter) # for plots
  reportLink <- paste0("https://dataknut.github.io/localCarbonTaxModels/", 
                       params$rmdFile, "_", rmdParams$filter,".html")
}

rmdParams$plotPath <- here::here("docs", "plots", rmdParams$filter, "/")
if(!dir.exists(rmdParams$plotPath)){
  dir.create(rmdParams$plotPath)
}
                                 
# Functions ----

```

\newpage

# About

This data notebook is based on a model presented at the 2021 [International Conference on Evolving Cities](https://evolvingcities.org/), University of Southampton, 22 – 24 September 2021.

If you want to cite the method/model please use:

Anderson, B. (2021). [Simulating the consequences of an emissions levy at the city and neighbourhood scale](https://eprints.soton.ac.uk/451507/). *Paper presented at the International Conference on Evolving Cities, MAST Mayflower Studios, Southampton, United Kingdom. 22 - 24 Sep 2021*.

If you are interested in how the model works start from  https://dataknut.github.io/localCarbonTaxModels/

# Citing this data notebook

If you wish to re-use material from this data notebook please cite it as:

`r params$authors` (`r lubridate::year(today())`) [`r params$title`: `r rParams$filter`](`r reportLink`).  University of Southampton, United Kingdom

License: [CC-BY](https://creativecommons.org/licenses/by/4.0/)

Share, adapt, give attribution.

# Highlights
This data notebook estimates the value of an emissions levy using LSOA level data on emissions derived from the CREDS place-based emissions calculator. These emissions are `all consumption`, `gas` and `electricity`. It does this under two scenarios - a simple carbon value multiplier and a rising block tariff. 

It then compares these with estimates of the cost of retrofitting EPC band dwellings D-E and F-G in each LSOA and for the whole area under study.

Key results:

 * Figure \@ref(fig:visIMDallCO2eperdw) shows the LSOA level per dwelling 'all emissions' in Tonnes CO2e - which areas emit the most?
 * Table \@ref(tab:scenario1Totals) shows total levy generated under Scenario 1
 * Table \@ref(tab:scenario2Totals) shows total levy generated under Scenario 2
 * Figure \@ref(fig:compareScenariosBarAll) compares the scenarios in terms of % of levy generated by areas in each IMD decile while Figure \@ref(fig:compareScenariosPlotAll) compares the levy generated under each scenario at LSOA level. In both cases, Scenario 2 should be lower in more deprived areas and higher in less deprived areas.
 * Table \@ref(tab:reportRetrofitCosts) shows total retrofit costs and Figure \@ref(fig:plotRetrofitCostsPerDwelling) shows the LSOA level retrofit costs per dwelling by IMD decile for comparison with Figure \@ref(fig:visIMDallCO2eperdw)
 * Figure \@ref(fig:allLevyPayOffSc1) shows the years to pay back under Scenario 1 for an all emissions levy while  * Figure \@ref(fig:allLevyPayOffSc2) does the same for Scenario 2
  * Figure \@ref(fig:transferVisAllSc1) shows what would happen after year 1 if the levy were shared equally across LSOAs (all emissions, Secenario 1) and Figure \@ref(fig:transferVisAllSc2) shows the same for Scenario 2.
 * Figure \@ref(fig:comparePayBack) shows payback years under each Scenario assuming a constant all emissions levy

# Emissions Levy Case Study: `r rParams$filter`

This data notebook estimates a model of an emissions levy using LSOA level data on emissions derived from the CREDS place-based emissions calculator. 

The model applies carbon 'values' to a number of emissions categories to estimate the levy revenue that would be generated for each LSOA in year 1 of such a levy. It then sums these values to given an overall levy revenue estimate for the area in the case study.

The data notebook then use estimates of the cost of retrofitting EPC band dwellings D-E and F-G together with estimates of the number of such dwellings in each of the LSOAs to calculate the likely cost of such upgrades in each LSOA and for the whole area in the case study.

Finally the data notebook compares the distributions of the two to understand whether sufficient revenue would be generated within each LSOA to enable the per-LSOA or whole case study area costs of the energy efficiency upgrades to be met. In doing so the data notebook also analyses the extent to which redistribution of revenue from high emissions areas (households) would be required. 

It should be noted that this area level analysis uses mean emissions per household. It will therefore _not_ capture within-LSOA heterogeneity in emissions and so will almost certainly underestimate the range of the household level emissions levy values that might be expected.

> NB: no maps in the interests of speed

## Data

The model uses a number of Lower Layer Super Output Area (LSOA) level datasets to analyse the patterns of emissions.

 * CREDS [place-based emissions](https://www.carbon.place/) estimates (contains data from a wide range of sources including https://epc.opendatacommunities.org/ for EPCs)
 * 2018 residential gas & [electricity](https://www.gov.uk/government/statistics/lower-and-middle-super-output-areas-electricity-consumption) use data
 * [Indices of Deprivation](https://www.gov.uk/government/statistics/english-indices-of-deprivation-2019 ) 2019 
 * [Urban/Rural classification](https://data.gov.uk/dataset/b1165cea-2655-4cf7-bf22-dfbd3cdeb242/rural-urban-classification-2011-of-lower-layer-super-output-areas-in-england-and-wales) at LSOA level
 * various LSOA look-up tables from [geoportal](https://geoportal.statistics.gov.uk/search?collection=Dataset&sort=name&tags=all(LUP_CEN))
 
> All analysis is at LSOA level. Cautions on inference from area level data apply.

```{r filterData}
# filter data here if needed ----
  
  if(rmdParams$filter == "All English LSOAs"){
    selectedLsoasDT <- mergedLSOA_Data_Eng 
    message("Filter: ", rmdParams$filter)
  } else { # filter
    message("Filter: ", rmdParams$filter)
    mergedLSOA_Data_Eng[, case_study := ifelse(LAD11NM %like% rmdParams$filter, 1, 0)] # use for comparisons
    selectedLsoasDT <- mergedLSOA_Data_Eng[LAD11NM %like% rmdParams$filter]
  }

# check
table(mergedLSOA_Data_Eng$case_study)

message("Selected rows:")
nrow(selectedLsoasDT)

```


## LSOA level emissions estimates

See https://www.creds.ac.uk/why-we-built-a-place-based-carbon-calculator/

"The highest carbon areas have an average per person footprint more than eight times larger than the lowest carbon areas."

"We are not effectively targeting decarbonisation policies in high carbon areas. For example, the recently collapsed Green Homes Grants scheme provided a grant to cover 66% of the cost (up to £5,000) of retrofitting homes.  For people claiming certain benefits, the cap was raised to 100% and £10,000. But the calculator shows that the big polluters are the large homes in very wealthy areas. In these neighbourhoods, the issue is not affordability but motivation. For high income households, energy costs are a small proportion of their expenditure and so the cost savings for retrofitting their home are inconsequential. As there are no policy “sticks” to incentivise action in the collective interest it is unsurprising that high carbon neighbourhoods have not prioritised decarbonisation."

Source: https://www.carbon.place/

Notes:

 * Emissions are presented as per capita...
 * Appears to be based on residential/citizen emissions only - does not appear to include commercial/manufacturing/land use etc

```{r CREDSpbcc}

# check some totals for confidence
t <- selectedLsoasDT[, .(nLSOAs = .N,
                mean_KgCo2ePerCap = mean(CREDS_total_kgco2e/pop_2018),
                sd_KgCo2ePerCap = sd(CREDS_total_kgco2e/pop_2018)),
            keyby = .(region)]

makeFlexTable(t, cap = paste0("Summary of CREDS per capita data for ", capFilter))

message("Do we have any missing energy data?")
t <- head(selectedLsoasDT[is.na(nElecMeters), .(LAD11NM, LSOA11CD, LSOA01NM, nElecMeters, nGasMeters,
                                           CREDS_total_kgco2e, CREDS_elec_kgco2e2018, CREDS_gas_kgco2e2018,
                                           CREDS_otherEnergy_kgco2e2011, CREDS_allHomeEnergy_kgco2e2011)])
makeFlexTable(t)
```

Now we need to convert the per capita to totals and then use the number of electricity meters as a proxy for the number of dwellings

Ideally we'd have Census 2021 data but we don't have it yet. So instead we'll use the number of electricity meters for 2018 which aligns with the CREDS data (might be an over-estimate if a dwelling has 2...)

First check the n electricity meters logic...

```{r check_nElecMeters}
# unallocated meters are in a row without a valid LSOA code
# one very large count
head(selectedLsoasDT[, .(LSOA11NM, WD18NM, nGasMeters, nElecMeters, epc_total)][order(-nGasMeters)])

head(selectedLsoasDT[, .(LSOA11NM, WD18NM, nGasMeters, nElecMeters, epc_total)][order(-nElecMeters)])

# keep only clean, allocated data
selectedLsoasDT <- selectedLsoasDT[!is.na(LSOA01NM)]
t <- head(selectedLsoasDT[, .(LSOA11NM, WD18NM, nGasMeters, nElecMeters, epc_total)][order(-nGasMeters)])
makeFlexTable(t, cap = "LSOAs with highest number of gas meters (after cleaning)")
```

Check that the number of electricity meters reasonably correlates with the number of EPCs from the CREDS data. We would _not_ expect the number of gas meters to correlate due to non-gas dwellings etc.

>There may also be difficulties where there are multiple meters per property - e.g. one 'standard' and one 'economy 7'. Really should switch to using address counts from postcode file.

```{r checkDwellingCounts}
p <- selectedLsoasDT[, .(BEIS_nGasMeters2018 = nGasMeters, 
                     BEIS_nElecMeters2018 = nElecMeters, 
                     CREDS_epc_total2020 = epc_total)]

pairs(p)


```

Check that the assumption seems sensible... 

> Check for outliers - what might this indicate?

### Estimate per dwelling emissions

We want to present the analysis in 'per dwelling' or 'per household' terms so we need to convert the total kg CO2e values to per dwelling values by dividing by the number of electricity meters.

```{r estimatePerDwellingCO2e}

selectedLsoasDT[, CREDS_total_kgco2e_pdw := CREDS_total_kgco2e/nElecMeters]

selectedLsoasDT[, CREDS_gas_kgco2e2018_pdw := CREDS_gas_kgco2e2018/nElecMeters]

selectedLsoasDT[, CREDS_elec_kgco2e2018_pdw := CREDS_elec_kgco2e2018/nElecMeters]

selectedLsoasDT[, CREDS_measuredHomeEnergy_kgco2e2018_pdw := (CREDS_gas_kgco2e2018 + CREDS_elec_kgco2e2018)/nElecMeters]

selectedLsoasDT[, CREDS_otherEnergy_kgco2e2011_pdw := CREDS_otherEnergy_kgco2e2011/nElecMeters]

selectedLsoasDT[, CREDS_allHomeEnergy_kgco2e2018_pdw:= (CREDS_elec_kgco2e2018 + CREDS_gas_kgco2e2018 + CREDS_otherEnergy_kgco2e2011)/nElecMeters]

selectedLsoasDT[, CREDS_car_kgco2e2018_pdw:= CREDS_car_kgco2e2018/nElecMeters]

selectedLsoasDT[, CREDS_van_kgco2e2018_pdw:= CREDS_van_kgco2e2018/nElecMeters]

selectedLsoasDT[, CREDS_personalTransport_kgco2e2018_pdw:= (CREDS_car_kgco2e2018 + CREDS_van_kgco2e2018)/nElecMeters]

t <- skimr::skim(selectedLsoasDT[, .(CREDS_total_kgco2e_pdw,CREDS_gas_kgco2e2018_pdw,CREDS_elec_kgco2e2018_pdw,
                             CREDS_measuredHomeEnergy_kgco2e2018_pdw,
                             CREDS_otherEnergy_kgco2e2011_pdw, CREDS_allHomeEnergy_kgco2e2018_pdw,
                             CREDS_car_kgco2e2018_pdw, CREDS_van_kgco2e2018_pdw, CREDS_personalTransport_kgco2e2018_pdw) ])

message("# Summary of per dwelling values")
t
```

Examine patterns of per dwelling emissions for sense.

#### All emissions

Figure \@ref(fig:visIMDallCO2eperdw) shows the LSOA level per dwelling 'all emissions' in Tonnes CO2e as estimated by the CREDS tool against the Index of Multiple Deprivation (IMD) score and uses the size of the points to represent the % of dwellings with electric heating. Colour is used to represent the IMD decile where decile 1 is the 10% least deprived.

```{r visIMDallCO2eperdw, fig.height = 5, fig.cap="Scatter of LSOA level all consumption emissions per dwelling against IMD score"}
message("Per dwelling T CO2e - all emissions")

# if this is all LSOAs in a larger area might want to use RUC11 instead of IMD_Decile_label to look at
# urban/rural distirbutions
ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, y = CREDS_total_kgco2e_pdw/1000)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "IMD 2019 score",
       y = "Estimated total T CO2e/household (CREDS, 2021)",
       caption = capFilter)
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_scatterIMD_CREDS_total_kgco2e_pdw.png"))

message("Correlation test (pwcorr)")
cor.test(selectedLsoasDT$IMDScore, selectedLsoasDT$CREDS_total_kgco2e_pdw)

dt <- selectedLsoasDT[, .(LSOA11CD, WD18NM, IMD_Decile_label, All_Tco2e_per_dw = CREDS_total_kgco2e_pdw/1000)]
t <- summary(dt)
message("Total emissions per dwelling (LSOA level) summary")
t

t <- head(dt[order(-All_Tco2e_per_dw)])
makeFlexTable(t, cap = "Highest emitting LSOAs (per dwelling)")
t <- head(dt[order(All_Tco2e_per_dw)])
makeFlexTable(t, cap = "Lowest emitting LSOAs (per dwelling)")
```


#### Home energy use

Figure \@ref(fig:visIMDgasCO2eperdw) uses the same plotting method to show emissions per dwelling due to gas use.

```{r visIMDgasCO2eperdw, fig.height = 5, fig.cap="Scatter of LSOA level gas per dwelling emissions against IMD score"}

message("Per dwelling T CO2e - gas emissions")

summary(selectedLsoasDT$CREDS_gas_kgco2e2018_pdw)

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, y = CREDS_gas_kgco2e2018_pdw/1000)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "IMD 2019 score",
       y = "Estimated gas T CO2e/household (CREDS, 2021)",
       caption = capFilter)
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_scatterIMD_CREDS_gas_kgco2e2018_pdw.png"))

message("Correlation test (pwcorr)")
cor.test(selectedLsoasDT$IMDScore, selectedLsoasDT$CREDS_gas_kgco2e2018_pdw)
```

Figure \@ref(fig:visIMDelecCO2eperdw) uses the same plotting method to show emissions per dwelling due to electricity use.

```{r visIMDelecCO2eperdw, fig.height = 5, fig.cap="Scatter of LSOA level elec per dwelling emissions against IMD score - who emits?"}

message("Per dwelling T CO2e - elec emissions")

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, y = CREDS_elec_kgco2e2018_pdw/1000)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "IMD 2019 score",
       y = "Estimated electricity T CO2e/household (CREDS, 2021)",
       caption = capFilter)
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_scatterIMD_CREDS_elec_kgco2e2018_pdw.png"))

message("Correlation test (pwcorr)")
cor.test(selectedLsoasDT$IMDScore, selectedLsoasDT$CREDS_elec_kgco2e2018_pdw)

```


Figure \@ref(fig:visIMDotherEnergyCO2eperdw) uses the same plotting method to show emissions per dwelling due to other energy use. This should be higher for off-gas areas which tend to be rural areas so we also present analysis by the LSOA's urban/rural classification.

```{r visIMDotherEnergyCO2eperdw, fig.height = 5, fig.cap="Scatter of LSOA level other energy per dwelling emissions against IMD score - who emits?"}

message("Per dwelling T CO2e - elec emissions")

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, y = CREDS_otherEnergy_kgco2e2011_pdw/1000)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "IMD 2019 score",
       y = "Estimated electricity T CO2e/household (CREDS, 2021)",
       caption = capFilter)
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_scatterIMD_CREDS_otherEnergy_kgco2e2018_pdw.png"))

message("Correlation test (pwcorr)")
cor.test(selectedLsoasDT$IMDScore, selectedLsoasDT$CREDS_elec_kgco2e2018_pdw)

t <- selectedLsoasDT[, .(mean_gas_kgco2e = mean(CREDS_gas_kgco2e2018_pdw),
                mean_elec_kgco2e = mean(CREDS_elec_kgco2e2018_pdw),
                mean_other_energy_kgco2e = mean(CREDS_otherEnergy_kgco2e2011_pdw)), 
                keyby = .(RUC11)] # only sensible for case styudy area which is a mix of urban/rural

makeFlexTable(t, cap = "Summary of per dwelling energy emissions for LSOAs by urban/rural code")
```

Check whether all _measured_ energy emissions combined (gas & electricity) correlate with all emissions (in this data).

```{r correlateAllandMeasuredEnergyEmissions}

cor.test(selectedLsoasDT$CREDS_total_kgco2e_pdw, selectedLsoasDT$CREDS_measuredHomeEnergy_kgco2e2018_pdw)

ggplot2::ggplot(selectedLsoasDT, aes(x = CREDS_total_kgco2e_pdw/1000, 
                                 y = CREDS_measuredHomeEnergy_kgco2e2018_pdw/1000)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Estimated total T CO2e/household (CREDS, 2021)",
       y = "Estimated measured energy T CO2e/household (CREDS, 2021)",
       caption = capFilter)
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_scatterCREDS_total_kgco2e_pdw_CREDS_measuredHomeEnergy_kgco2e2018_pdw.png"))
```

Do we see strong correlations? If so in theory we could (currently) use measured energy emissions as a proxy for total emissions.

Repeat for all home energy - includes estimates of emissions from oil etc

```{r correlateAllandHomeEnergyEmissions}

cor.test(selectedLsoasDT$CREDS_total_kgco2e_pdw, selectedLsoasDT$CREDS_allHomeEnergy_kgco2e2018_pdw)

ggplot2::ggplot(selectedLsoasDT, aes(x = CREDS_total_kgco2e_pdw/1000, 
                                 y = CREDS_allHomeEnergy_kgco2e2018_pdw/1000)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Estimated total T CO2e/household (CREDS, 2021)",
       y = "Estimated total home energy T CO2e/household (CREDS, 2021)",
       caption = capFilter)
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_scatterCREDS_total_kgco2e_pdw_CREDS_measuredHomeEnergy_kgco2e2018_pdw.png"))
```

How does the correlation look now?

#### Transport

We don't expect to use this data as it is already taxed in a way that relates to emissions (?)

Figure \@ref(fig:visIMDcarCO2eperdw) uses the same plotting method to show emissions per dwelling due to van use. Again, we present analysis by the LSOA's urban/rural classification.

```{r visIMDcarCO2eperdw, fig.height = 5, fig.cap="Scatter of LSOA level car use per dwelling emissions against IMD score"}

message("Per dwelling T CO2e - car emissions")

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, y = CREDS_car_kgco2e2018_pdw/1000)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "IMD 2019 score",
       y = "Estimated electricity T CO2e/household (CREDS, 2021)",
       caption = capFilter)
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_scatterIMD_CREDS_car_kgco2e2018_pdw.png"))

message("Correlation with IMD score (pwcorr)")
cor.test(selectedLsoasDT$IMDScore, selectedLsoasDT$CREDS_car_kgco2e2018_pdw)

t <- selectedLsoasDT[, .(mean_car_kgco2e = mean(CREDS_car_kgco2e2018_pdw),
                mean_van_kgco2e = mean(CREDS_van_kgco2e2018_pdw)), 
                keyby = .(RUC11)] # only sensible for case styudy area which is a mix of urban/rural

makeFlexTable(t, cap = "Summary of per dwelling transport emissions for LSOAs by urban/rural code")

```

Figure \@ref(fig:visIMDvanCO2eperdw) uses the same plotting method to show emissions per dwelling due to van use.

```{r visIMDvanCO2eperdw, fig.height = 5, fig.cap="Scatter of LSOA level van use per dwelling emissions against IMD score"}

message("Per dwelling T CO2e - van emissions")

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, y = CREDS_van_kgco2e2018_pdw/1000)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "IMD 2019 score",
       y = "Estimated van use T CO2e/household (CREDS, 2021)",
       caption = capFilter)
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_scatterIMD_CREDS_van_kgco2e2018_pdw.png"))

message("Correlation with IMD score (pwcorr)")
cor.test(selectedLsoasDT$IMDScore, selectedLsoasDT$CREDS_van_kgco2e2018_pdw)

```

### Estimating the annual emissions levy

Case studies:

 * Annual carbon tax
 * Half-hourly (real time) carbon tax (_not implemented_) - this would only affect electricity

BEIS/ETC Carbon ‘price’

 * 2020 - £21.93 https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/849276/Carbon__Penalty_Price_Determination_for_2020.pdf 

EU carbon ‘price’

 * September 2021: €60 (£51) https://tradingeconomics.com/eecxm:ind

BEIS Carbon ‘Value’ https://www.gov.uk/government/publications/valuing-greenhouse-gas-emissions-in-policy-appraisal/valuation-of-greenhouse-gas-emissions-for-policy-appraisal-and-evaluation#annex-1-carbon-values-in-2020-prices-per-tonne-of-co2

 * based on a Marginal Abatement Cost (MAC)
 * 2021: 
    * Low: £122/T
    * Central: £245/T <- use the central value for now
    * High: £367/T

Scenario 1: apply the central value
Scenario 2: apply the low/central/high as a rising block tariff for each emissions source. Set threhsolds to 33% and 66% (in absence of any other guidance!)

#### Scenario 1: Central carbon cost

```{r estimateAnnualLevy_scenario1}
# carbon costs
eu_ets <- 51
beis_l <- 122
beis_c <- 245
beis_h <- 367

selectedLsoasDT[, eu_ets_GBPtotal := CREDS_total_kgco2e/1000 * eu_ets] # £ in tonnes so /1000
selectedLsoasDT[, eu_ets_GBPtotal_perdw := eu_ets_GBPtotal/nElecMeters]

selectedLsoasDT[, beis_GBPtotal_l := CREDS_total_kgco2e/1000 * beis_l]
selectedLsoasDT[, beis_GBPtotal_l_perdw := beis_GBPtotal_l/nElecMeters]
selectedLsoasDT[, beis_GBPtotal_l_gas := CREDS_gas_kgco2e2018/1000 * beis_l]
selectedLsoasDT[, beis_GBPtotal_l_elec := CREDS_elec_kgco2e2018/1000 * beis_l]
selectedLsoasDT[, beis_GBPtotal_l_gas_perdw := beis_GBPtotal_l_gas/nElecMeters]
selectedLsoasDT[, beis_GBPtotal_l_elec_perdw := beis_GBPtotal_l_elec/nElecMeters]

selectedLsoasDT[, beis_GBPtotal_c := CREDS_total_kgco2e/1000 * beis_c]
selectedLsoasDT[, beis_GBPtotal_c_perdw := beis_GBPtotal_c/nElecMeters]
selectedLsoasDT[, beis_GBPtotal_c_gas := CREDS_gas_kgco2e2018/1000 * beis_c]
selectedLsoasDT[, beis_GBPtotal_c_elec := CREDS_elec_kgco2e2018/1000 * beis_c]
selectedLsoasDT[, beis_GBPtotal_c_gas_perdw := beis_GBPtotal_c_gas/nElecMeters]
selectedLsoasDT[, beis_GBPtotal_c_elec_perdw := beis_GBPtotal_c_elec/nElecMeters]

selectedLsoasDT[, beis_GBPtotal_h := CREDS_total_kgco2e/1000 * beis_h]
selectedLsoasDT[, beis_GBPtotal_h_gas := CREDS_gas_kgco2e2018/1000 * beis_h]
selectedLsoasDT[, beis_GBPtotal_h_elec := CREDS_elec_kgco2e2018/1000 * beis_h]
selectedLsoasDT[, beis_GBPtotal_h_perdw := beis_GBPtotal_h/nElecMeters]
selectedLsoasDT[, beis_GBPtotal_h_gas_perdw := beis_GBPtotal_h_gas/nElecMeters]
selectedLsoasDT[, beis_GBPtotal_h_elec_perdw := beis_GBPtotal_h_elec/nElecMeters]

selectedLsoasDT[, beis_GBPtotal_c_energy := beis_GBPtotal_c_gas + beis_GBPtotal_c_elec]
selectedLsoasDT[, beis_GBPtotal_c_energy_perdw := beis_GBPtotal_c_gas_perdw + beis_GBPtotal_c_elec_perdw]
```


Table \@ref(tab:scenario1Totals) below shows the overall £ GBP total for the case study area in £M under Scenario 1.

```{r scenario1Totals, fig.cap="Proportion of total emissions due to gas & electricity use by region covered"}
m <- 1000000

t <- selectedLsoasDT[, .(nLSOAs = .N, beis_GBPtotal_c = sum(beis_GBPtotal_c)/m,
                     beis_total_c_gas = sum(beis_GBPtotal_c_gas)/m,
                     beis_GBPtotal_c_elec = sum(beis_GBPtotal_c_elec)/m)]
makeFlexTable(t[order(-beis_GBPtotal_c)], cap = "Total £m GBP levy by source")


t <- selectedLsoasDT[, .(nLSOAs = .N, beis_GBPtotal_c = sum(beis_GBPtotal_c)/m,
                     beis_total_c_gas = sum(beis_GBPtotal_c_gas)/m,
                     beis_GBPtotal_c_elec = sum(beis_GBPtotal_c_elec)/m), keyby = .(region)]

makeFlexTable(t[order(-beis_GBPtotal_c)], cap = "Total £m GBP levy by source, ordered by highest emitting region")

mt <- melt(t)
ggplot2::ggplot(mt[variable != "nLSOAs"], aes(x = reorder(region, -value), y = value, fill = variable)) +
  geom_col(position = "stack") +
  labs(caption = capFilter)
```

The table below shows the mean per dwelling value rounded to the nearest £10.

```{r GBP_beis_c_perdw}

t <- selectedLsoasDT[, .(All_emissions = mean(beis_GBPtotal_c_perdw),
                     Gas = mean(beis_GBPtotal_c_gas_perdw),
                     Electricity = mean(beis_GBPtotal_c_elec_perdw),
                     `Gas + Electricity` = mean(beis_GBPtotal_c_energy_perdw))]

makeFlexTable(t, cap = "Mean £ GBP levy per dwelling by source")

```

Figure \@ref(fig:whoWinsBEIScAll) shows the total £k per LSOA and £ per dwelling revenue using BEIS central carbon price plotted against IMD score. The tables show the LSOAs with the highest and lowest values.

```{r whoWinsBEIScAll, fig.cap = "£k per LSOA revenue using BEIS central carbon price"}
emissionsCap <- "All emissions"
  
ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_c/1000)) +
  geom_point(aes(colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon cost' £k total",
       caption = paste0(emissionsCap, "\n", capFilter))
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWins_beis_GBPtotal_c.png"))

med <- median(selectedLsoasDT$beis_GBPtotal_c_perdw)

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_perdw)) +
  geom_hline(yintercept = med, colour = "orange") +
  geom_point(aes(colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon cost' £ per dwelling",
       caption = paste0(emissionsCap, "\n", capFilter))
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWins_beis_GBPtotal_c_perdw.png"))
ggplot2::ggsave(paste0(rmdParams$plotPath, "BC_r1_Figure_6.jpg"))

summary(selectedLsoasDT$beis_GBPtotal_c_perdw)

dt <- selectedLsoasDT[, .(LSOA11CD, LSOA01NM, WD18NM, T_CO2e_pdw = CREDS_total_kgco2e_pdw/1000, GBP_allEmissions_levy = beis_GBPtotal_c_perdw, msoa_tot_annual_income_2018)]

t <- head(dt[order(-GBP_allEmissions_levy)])
makeFlexTable(t, cap = "Highest levy LSOAs")
t <-head(dt[order(GBP_allEmissions_levy)])
makeFlexTable(t, cap = "Lowest levy LSOAs")
```

Figure \@ref(fig:whoWinsBEIScGas) repeats the analysis but just for gas. 

Anything unusual?

```{r whoWinsBEIScGas, fig.cap = "£k per LSOA incurred via gas using BEIS central carbon price"}
emissionsCap <- "Emissions due to gas"

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_gas/1000)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon cost' £k",
       caption = paste0(emissionsCap, "\n", capFilter))
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWinsBEIS_c_gas_total.png"))

med <- median(selectedLsoasDT$beis_GBPtotal_c_gas_perdw)

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_gas_perdw)) +
  geom_hline(yintercept = med, colour = "orange") +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon cost' £ per dwelling",
       caption = paste0(emissionsCap, "\n", capFilter))
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWinsBEIS_c_gas_perdw.png"))

summary(selectedLsoasDT$beis_GBPtotal_c_gas_perdw)

dt <- selectedLsoasDT[, .(LSOA11CD, LSOA01NM,WD18NM, gas_T_CO2e_pdw = CREDS_gas_kgco2e2018_pdw/1000, GBP_gas_levy_perdw = beis_GBPtotal_c_gas_perdw, msoa_tot_annual_income_2018)]


t <- head(dt[order(-GBP_gas_levy_perdw)])
makeFlexTable(t, cap = "Highest emitting by £ GBP gas levy")
t <- tail(dt[order(-GBP_gas_levy_perdw)])
makeFlexTable(t, cap = "Lowest emitting by £ GBP gas levy")
```

Figure \@ref(fig:whoWinsBEIScElec) repeats the analysis for electricity.

```{r whoWinsBEIScElec, fig.cap = "£k per LSOA incurred via electricity using BEIS central carbon price"}

emissionsCap <- "Emissions due to electricity"

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_elec/1000)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon cost' £k",
       caption = paste0(emissionsCap, "\n", capFilter))
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWinsBEIS_c_elec_total.png"))

med <- median(selectedLsoasDT$beis_GBPtotal_c_elec_perdw)

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_elec_perdw)) +
  geom_hline(yintercept = med, colour = "orange") +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon cost' £ per dwelling",
       caption = paste0(emissionsCap, "\n", capFilter))
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWinsBEIS_c_elec_perdw.png"))

summary(selectedLsoasDT$beis_GBPtotal_c_elec_perdw)

dt <- selectedLsoasDT[, .(LSOA11CD, LSOA01NM, WD18NM, elec_T_CO2e_pdw = CREDS_elec_kgco2e2018_pdw/1000, GBP_elec_levy_perdw = beis_GBPtotal_c_elec_perdw, msoa_tot_annual_income_2018)]


t <- head(dt[order(-GBP_elec_levy_perdw)])
makeFlexTable(t, cap = "Highest emitting by £ GBP electricity levy")
t <- tail(dt[order(-GBP_elec_levy_perdw)])
makeFlexTable(t, cap = "Lowest emitting by £ GBP electricity levy")
```

Figure \@ref(fig:whoWinsBEIScEnergy) shows the same analysis for measured energy (elec + gas)

```{r whoWinsBEIScEnergy, fig.cap = "£k per LSOA incurred via electricity and gas using BEIS central carbon price"}

emissionsCap <- "Emissions due to electricity & gas"

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_energy/1000)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon cost' £k",
       caption = paste0(emissionsCap, "\n", capFilter))
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWinsBEIS_c_energy_total.png"))

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_c_energy_perdw)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS central 'carbon cost' £ per dwelling",
       caption = paste0(emissionsCap, "\n", capFilter))
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWinsBEIS_c_energy_perdw.png"))
ggplot2::ggsave(paste0(rmdParams$plotPath, "BC_r1_Figure_7.jpg"))

summary(selectedLsoasDT$beis_GBPtotal_c_energy_perdw)
```

#### Scenario 2: Rising block tariff

Applied  to per dwelling values (not LSOA total) - may be methodologically dubious?

Cut at 25%, 50% - so any emissions over 50% get high carbon cost

```{r estimateAnnualLevyScenario2Total}
# carbon costs

beis_l <- 122
beis_c <- 245
beis_h <- 367

# total ----
cut_total_pdw <- quantile(selectedLsoasDT$CREDS_total_kgco2e_pdw, probs = seq(0,1,0.25))
cut_c <- cut_total_pdw[[2]]
cut_h <- cut_total_pdw[[3]]
message("Cuts for total per dw")
cut_total_pdw

ggplot2::ggplot(selectedLsoasDT, aes(x = CREDS_total_kgco2e_pdw)) +
  geom_histogram() +
  geom_vline(xintercept = cut_c,colour = "blue") +
  geom_vline(xintercept = cut_h,colour = "red")

# low
selectedLsoasDT[, beis_GBPtotal_sc2_l_perdw := ifelse(CREDS_total_kgco2e_pdw <= cut_c,
                                        CREDS_total_kgco2e_pdw/1000 * beis_l,
                                        cut_c/1000 * beis_l )]
# central
# step 1
selectedLsoasDT[, beis_GBPtotal_sc2_c_perdw := ifelse(CREDS_total_kgco2e_pdw > cut_c & # in the middle range
                                                    CREDS_total_kgco2e_pdw < cut_h,
                                        (CREDS_total_kgco2e_pdw - cut_c)/1000 * beis_c, # the part in the range
                                        0 )] # for now as default - applies where CREDS_total_kgco2e_pdw <= cut_c
# step 2
selectedLsoasDT[, beis_GBPtotal_sc2_c_perdw := ifelse(CREDS_total_kgco2e_pdw > cut_h, # above range
                                        (cut_h - cut_c)/1000 * beis_c, # the total bit in the range
                                        beis_GBPtotal_sc2_c_perdw )] # the value from above if CREDS_total_kgco2e_pdw < cut_h

# high
selectedLsoasDT[, beis_GBPtotal_sc2_h_perdw := ifelse(CREDS_total_kgco2e_pdw >= cut_h, # above range
                                        (CREDS_total_kgco2e_pdw - cut_h)/1000 * beis_h, # the total bit in the range
                                        0 )] # the value if CREDS_total_kgco2e_pdw < cut_total_66
# sum
selectedLsoasDT[, beis_GBPtotal_sc2_perdw := beis_GBPtotal_sc2_l_perdw + beis_GBPtotal_sc2_c_perdw + beis_GBPtotal_sc2_h_perdw]

# test
#head(selectedLsoasDT[, .(CREDS_total_kgco2e_pdw/1000, beis_GBPtotal_sc2_l_perdw, beis_GBPtotal_sc2_c_perdw, beis_GBPtotal_sc2_h_perdw, beis_GBPtotal_sc2_perdw)], 10)

# calculate the sum by multiplying by n dwellings
selectedLsoasDT[, beis_GBPtotal_sc2 := beis_GBPtotal_sc2_perdw * nElecMeters]

# totals
skimr::skim(selectedLsoasDT[, .(CREDS_total_kgco2e_pdw/1000, beis_GBPtotal_sc2_perdw, beis_GBPtotal_sc2)])
```

```{r estimateAnnualLevyScenario2gas}
# gas ----
cut_gas_pdw <- quantile(selectedLsoasDT$CREDS_gas_kgco2e2018_pdw, probs = seq(0,1,0.25))
cut_c <- cut_gas_pdw[[2]]
cut_h <- cut_gas_pdw[[3]]

selectedLsoasDT$beis_GBPgas_sc2_l_perdw <- NULL
selectedLsoasDT$beis_GBPgas_sc2_c_perdw <- NULL
selectedLsoasDT$beis_GBPgas_sc2_h_perdw <- NULL
# low
selectedLsoasDT[, beis_GBPgas_sc2_l_perdw := ifelse(CREDS_gas_kgco2e2018_pdw <= cut_c,
                                        (CREDS_gas_kgco2e2018_pdw/1000) * beis_l, # less than cut_c
                                        (cut_c/1000) * beis_l )] # more than cut_c so constant
#head(selectedLsoasDT[, .( CREDS_gas_kgco2e2018_pdw, beis_GBPgas_sc2_l_perdw)])
# central
# step 1
selectedLsoasDT[, beis_GBPgas_sc2_c_perdw := ifelse(CREDS_gas_kgco2e2018_pdw > cut_c & # in the middle range
                                                    CREDS_gas_kgco2e2018_pdw < cut_h,
                                        ((CREDS_gas_kgco2e2018_pdw - cut_c)/1000) * beis_c, # the part in the range
                                        0 )] # for now as default - applies where CREDS_gas_kgco2e2018_pdw <= cut_c

# step 2
selectedLsoasDT[, beis_GBPgas_sc2_c_perdw := ifelse(CREDS_gas_kgco2e2018_pdw > cut_h, # above range
                                        ((cut_h - cut_c)/1000) * beis_c, # the total bit in the range
                                        beis_GBPgas_sc2_c_perdw)] # the value from above if CREDS_gas_kgco2e2018_pdw < cut_h

# high
selectedLsoasDT[, beis_GBPgas_sc2_h_perdw := ifelse(CREDS_gas_kgco2e2018_pdw >= cut_h, # above range
                                        ((CREDS_gas_kgco2e2018_pdw - cut_h)/1000) * beis_h, # the total bit in the range
                                        0 )] # the value if CREDS_gas_kgco2e2018_pdw < cut_h
# sum
selectedLsoasDT[, beis_GBPgas_sc2_perdw := beis_GBPgas_sc2_l_perdw + beis_GBPgas_sc2_c_perdw + beis_GBPgas_sc2_h_perdw]
# test
#head(selectedLsoasDT[, .( CREDS_gas_kgco2e2018_pdw, beis_GBPgas_sc2_l_perdw, beis_GBPgas_sc2_c_perdw, beis_GBPgas_sc2_h_perdw, beis_GBPgas_sc2_perdw)])
# calculate the sum by multiplying by n dwellings
selectedLsoasDT[, beis_GBPgas_sc2 := beis_GBPgas_sc2_perdw * nElecMeters]
sum(selectedLsoasDT$beis_GBPgas_sc2)/1000000
```

```{r estimateAnnualLevyScenario2elec}

# electricity ----
cut_elec_pdw <- quantile(selectedLsoasDT$CREDS_elec_kgco2e2018_pdw, probs = seq(0,1,0.1))
cut_c <- cut_elec_pdw[[2]]
cut_h <- cut_elec_pdw[[3]]
# low
selectedLsoasDT[, beis_GBPelec_sc2_l_perdw := ifelse(CREDS_elec_kgco2e2018_pdw <= cut_c,
                                        CREDS_elec_kgco2e2018_pdw/1000 * beis_l,
                                        cut_c/1000 * beis_l )]
# central
# step 1
selectedLsoasDT[, beis_GBPelec_sc2_c_perdw := ifelse(CREDS_elec_kgco2e2018_pdw > cut_c & # in the middle range
                                                    CREDS_elec_kgco2e2018_pdw < cut_h,
                                        (CREDS_elec_kgco2e2018_pdw - cut_c)/1000 * beis_c, # the part in the range
                                        0 )] # for now as default - applies where CREDS_elec_kgco2e2018_pdw <= cut_c
# step 2
selectedLsoasDT[, beis_GBPelec_sc2_c_perdw := ifelse(CREDS_elec_kgco2e2018_pdw > cut_h, # above range
                                        (cut_h - cut_c)/1000 * beis_c, # the total bit in the range
                                        beis_GBPelec_sc2_c_perdw )] # the value from above if CREDS_elec_kgco2e2018_pdw < cut_elec_66

# high
selectedLsoasDT[, beis_GBPelec_sc2_h_perdw := ifelse(CREDS_elec_kgco2e2018_pdw >= cut_h, # above range
                                        (CREDS_elec_kgco2e2018_pdw - cut_h)/1000 * beis_h, # the total bit in the range
                                        0 )] # the value if CREDS_elec_kgco2e2018_pdw < cut_h
# sum
selectedLsoasDT[, beis_GBPelec_sc2_perdw := beis_GBPelec_sc2_l_perdw + beis_GBPelec_sc2_c_perdw + beis_GBPelec_sc2_h_perdw]

# calculate the sum by multiplying by n dwellings
selectedLsoasDT[, beis_GBPelec_sc2 := beis_GBPelec_sc2_perdw * nElecMeters]
sum(selectedLsoasDT$beis_GBPelec_sc2)/1000000

```

```{r plotScenario2}


plotDT <- selectedLsoasDT[, .(sum_sc1_kGBP = sum(beis_GBPtotal_c)/1000,
                      sum_sc2_kGBP = sum(beis_GBPtotal_sc2)/1000), keyby = .(IMD_Decile_label)]

plotDT[, sum_sc1_kGBP_prop := sum_sc1_kGBP/sum(sum_sc1_kGBP)]
plotDT[, sum_sc2_kGBP_prop := sum_sc2_kGBP/sum(sum_sc2_kGBP)]

m <- melt(plotDT)
m[, variable_lab := ifelse(variable %like% "sum_sc1", "Scenario 1", "Scenario 2")]

# test
#head(selectedLsoasDT[, .(CREDS_total_kgco2e_pdw/1000, beis_GBPtotal_sc2_l_perdw, beis_GBPtotal_sc2_c_perdw, beis_GBPtotal_sc2_h_perdw, beis_GBPtotal_sc2_perdw)], 10)


dt <- selectedLsoasDT[, .(LSOA11CD, LSOA01NM, WD18NM, T_CO2e_pdw = CREDS_total_kgco2e_pdw/1000, GBP_allEmissions_levy = beis_GBPtotal_sc2_perdw)]

t <- head(dt[order(-GBP_allEmissions_levy)])
makeFlexTable(t, cap = "Highest levy LSOAs")
t <-head(dt[order(GBP_allEmissions_levy)])
makeFlexTable(t, cap = "Lowest levy LSOAs")

dt <- selectedLsoasDT[, .(LSOA11CD, LSOA01NM, WD18NM, T_CO2e_pdw = CREDS_gas_kgco2e2018_pdw/1000, GBP_gasEmissions_levy = beis_GBPgas_sc2_perdw)]

t <- head(dt[order(-GBP_gasEmissions_levy)])
makeFlexTable(t, cap = "Highest levy LSOAs")
t <-head(dt[order(GBP_gasEmissions_levy)])
makeFlexTable(t, cap = "Lowest levy LSOAs")

dt <- selectedLsoasDT[, .(LSOA11CD, LSOA01NM, WD18NM, T_CO2e_pdw = CREDS_elec_kgco2e2018_pdw/1000, GBP_elecEmissions_levy = beis_GBPelec_sc2_perdw)]

t <- head(dt[order(-GBP_elecEmissions_levy)])
makeFlexTable(t, cap = "Highest levy LSOAs")
t <-head(dt[order(GBP_elecEmissions_levy)])
makeFlexTable(t, cap = "Lowest levy LSOAs")

med <- median(selectedLsoasDT$beis_GBPtotal_sc2_perdw)
emissionsCap <- "All consumption emissions"
ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, 
                            y = beis_GBPtotal_sc2_perdw)) +
  geom_hline(yintercept = med, colour = "orange") +
  geom_point(aes(colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "BEIS 'carbon cost' £ per dwelling (Scenario 2)",
       caption = paste0(emissionsCap, "\n", capFilter))
```

### Compare scenarios

Figure \@ref(fig:compareScenariosBarAll) compares the % £ levy under each scenario for all consumption contributed by LSOAs in each IMD decile.

```{r compareScenariosBarAll, fig.cap="Comparing £ levy under each scenario by IMD decile - all consumption emissions"}
ggplot2::ggplot(m[variable %like% "_prop"], aes(x = IMD_Decile_label, y = 100*value, 
                                                fill = variable_lab)) +
  geom_col(position = "dodge") +
  scale_fill_discrete(name = "Scenario") +
  labs(x = "IMD Decile",
         y = "% of revenue",
       caption = capFilter)

#ggplot2::ggsave(filename = here::here("plots/allLSOAs_compareScenarios_beis_GBP_propTotalByIMD.png"))

plotDT <- selectedLsoasDT[, .(beis_GBPtotal_c, beis_GBPtotal_sc2, IMD_Decile_label)]

t <- plotDT[, .(nLSOAs = .N, sum_total_sc1 = sum(beis_GBPtotal_c)/1000000,
       sum_total_sc2 = sum(beis_GBPtotal_sc2)/1000000)]
makeFlexTable(t, cap = "Compare totals for Scenario 1 & Scenario 2 (£m)")

m_plotDT <- melt(plotDT)
m_plotDT[, variable_lab := ifelse(variable == "beis_GBPtotal_c",
                                  "Scenario 1",
                                  "Scenario 2")]
ggplot2::ggplot(m_plotDT, aes(x = IMD_Decile_label, y = value/1000000, colour = variable_lab)) +
  geom_boxplot(aes()) +
  scale_color_discrete(name="Scenarios") +
  labs(x = "IMD decile",
       y = "Levy (£ m)",
       caption = capFilter)

ggplot2::ggsave(paste0(rmdParams$plotPath, "BC_r1_Figure_10.jpg"))

```

Figure \@ref(fig:compareScenariosPlotAll) compares the £ levy under each scenario for all consumption.

```{r compareScenariosPlotAll, fig.cap="Comparing £ levy under each scenario - all consumption emissions"}
ggplot2::ggplot(selectedLsoasDT, aes(x = beis_GBPtotal_c/1000000, y = beis_GBPtotal_sc2/1000000, 
                                 colour = IMD_Decile_label)) +
  geom_abline(slope = 1, intercept = 0) +
  scale_color_discrete(name = "IMD decile") +
  geom_point() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Scenario 1 £M per LSOA",
       y = "Scenario 2 £M per LSOA",
       caption = paste0(capFilter, "\nAll emissions, x = y line plotted for clarity"))

#ggplot2::ggsave(filename = here::here("plots/allLSOAs_compareScenarios_beis_GBPtotal_perLSOA_scatter.png"))
```


```{r compareScenariosPlotGas}
ggplot2::ggplot(selectedLsoasDT, aes(x = beis_GBPtotal_c_gas/1000000, y = beis_GBPgas_sc2/1000000, 
                                 colour = IMD_Decile_label)) +
  geom_abline(slope = 1, intercept = 0) +
  scale_color_discrete(name = "IMD decile") +
  geom_point() +
  labs(x = "Scenario 1 £M per LSOA",
       y = "Scenario 2 £M per LSOA",
       caption = paste0(capFilter, "\nGas emissions, x = y line plotted for clarity"))

#ggplot2::ggsave(filename = here::here("plots/allLSOAs_compareScenarios_beis_GBPgas_perLSOA_scatter.png"))
```


```{r compareScenariosPlotElec}
ggplot2::ggplot(selectedLsoasDT, aes(x = beis_GBPtotal_c_elec/1000000, y = beis_GBPelec_sc2/1000000, 
                                 colour = IMD_Decile_label)) +
  geom_abline(slope = 1, intercept = 0) +
  scale_color_discrete(name = "IMD decile") +
  geom_point() +
  labs(x = "Scenario 1 £M per LSOA",
       y = "Scenario 2 £M per LSOA",
       caption = paste0(capFilter, "\nElectricity emissions, x = y line plotted for clarity"))

#ggplot2::ggsave(filename = here::here("plots/allLSOAs_compareScenarios_beis_GBPelec_perLSOA_scatter.png"))
```

```{r scenario2Totals}
m <- 1000000
t <- selectedLsoasDT[, .(nLSOAs = .N, sumAllConsEmissions_GBP = sum(beis_GBPtotal_sc2)/m,
                sumGasEmissions_GBP = sum(beis_GBPgas_sc2)/m,
                sumElecEmissions_GBP = sum(beis_GBPelec_sc2)/m)]
makeFlexTable(t, cap =paste0("Scenario 2 totals for: ", rParams$filter, " (£ m)"))

t <- selectedLsoasDT[, .(nLSOAs = .N, sumAllConsEmissions_GBP = sum(beis_GBPtotal_sc2)/m,
                sumGasEmissions_GBP = sum(beis_GBPgas_sc2)/m,
                sumElecEmissions_GBP = sum(beis_GBPelec_sc2)/m,
                sumPop = sum(pop_2018)), keyby = region]
makeFlexTable(t[order(-sumAllConsEmissions_GBP)], cap = "Scenario 2 totals by region - if multiple regions (£ m)")


```

```{r scenario2Proportions, fig.cap="Contribution to sum levy £ GBP by source"}
mt <- melt(t)
ggplot2::ggplot(mt[variable != "nLSOAs" & variable != "sumPop"], aes(x = reorder(region, -value), y = value, fill = variable)) +
  geom_col(position = "stack") +
  labs(x = "Region",
       y = "Levy (£m GBP)",
       caption = capFilter)
```

## Estimate retofit costs

 * from A-E <- £13,300
 * from F-G <- £26,800

Source: English Housing Survey [2018 Energy Report](https://www.gov.uk/government/statistics/english-housing-survey-2018-energy-report)

> Model excludes EPC A, B & C (assumes no need to upgrade)

Adding these back in would increase the cost... obvs

### Impute EPC counts

There are likely to be a range of  biases in the EPC sample such as:

 * required for new builds
 * required for rental
 * required for sale
 * required after some retrofit

Check distributions of EPCs against known building stock:

 * Census dwelling type vs EPC dwelling type
 * Census dwelling age (?) vs EPC building age
 * Census main heating type ? vs EPC "mainfuel_mainsgas"              "mainfuel_electric" "mainfuel_oil"  "mainfuel_coal"  "mainfuel_lpg" "mainfuel_biomass"

```{r checkEPCDistns}
ggplot2::ggplot(selectedLsoasDT, aes(x = c2011_detached, 
                                     y  = CREDS_epc_Whole_House_Detached,
                                     colour = IMD_Decile_label)) +
  geom_point() + 
  scale_color_viridis_d() +
  geom_abline(slope = 1, intercept = 0)

ggplot2::ggplot(selectedLsoasDT, aes(x = c2011_semi, y  = CREDS_epc_Whole_House_Semi,
                                     colour = IMD_Decile_label)) +
  geom_point() + 
  scale_color_viridis_d() +
  geom_abline(slope = 1, intercept = 0)

ggplot2::ggplot(selectedLsoasDT, aes(x = c2011_terrace, y  = CREDS_epc_Whole_House_Terraced ,
                                     colour = IMD_Decile_label)) +
  geom_point() + 
  scale_color_viridis_d() +
  geom_abline(slope = 1, intercept = 0)

ggplot2::ggplot(selectedLsoasDT, aes(x = c2011_flat, y  = CREDS_epc_Whole_House_Flat , 
                                     colour = IMD_Decile_label)) +
  geom_point() + 
  scale_color_viridis_d() +
  geom_abline(slope = 1, intercept = 0)

ggplot2::ggplot(selectedLsoasDT, aes(x = nElecMeters, y  = epc_total , 
                                     colour = IMD_Decile_label)) +
  geom_point() + 
  scale_color_viridis_d() +
  geom_abline(slope = 1, intercept = 0)

summary(selectedLsoasDT[, .(pc_missing_epcs = 100*(nElecMeters- epc_total)/nElecMeters)])
```

These plots suggest:

 * Lots of detached houses missing - especially in lower deprivation areas
 * Lots of semis missing
 * Terrace houses better represented
 * Flats fairly well represented
 * Overall compared to the number of electricity meters, we have about 40% of the EPCs we should have

In order to estimate the LSOA level retrofit costs, we need to impute the EPC counts in each LSOA. We do this using the number of electricity meters as the presumed number of dwellings and the observed % of EPCs in each band for all dwellings with EPCs which is provided by the CREDS data. We simnply upweight the EPC counts proportionally so that the total matches the number of electricity meters.

Note that this _assumes_ that if we had EPCs for all dwellings then the % in each band in each LSOA would stay the same. This is quite a bold assumption given what we have seen above but there is currently no way to re-weight them (e.g. to fit the dwelling type counts) with the data we have - we do not know the  of EPCs of each Band that come from different dwelling types.

> Note to self: this could be done by re-weighting the case level EPC data using Census outcomes at LSOA level - e.g. via IPF

Note that the EPC database is continuously updated so more recent upgrades will not be captured in the data used for this analysis. This means the total retrofit costs are likely to be an over-estimate. The extent of this over-estimate would require the use of an updated (current) EPC data extract and is left for future work.

```{r impute_EPC_counts}
# CREDS data has counts - we know there are missing EPCs
message("N EPCs")
summary(selectedLsoasDT$epc_total)
message("N elec meters")
summary(selectedLsoasDT$nElecMeters)

# We will assume the distribution of EPCs across bands within LSOAs is unbiased
# So the % will be OK but the count will be wrong
impute_epcs <- function(dt){
  # wrap in a function so we can re-use easily
  dt[, epc_A_pc := epc_A/epc_total]
  dt[, epc_B_pc := epc_B/epc_total]
  dt[, epc_C_pc := epc_C/epc_total]
  dt[, epc_D_pc := epc_D/epc_total]
  dt[, epc_E_pc := epc_E/epc_total]
  dt[, epc_F_pc := epc_F/epc_total]
  dt[, epc_G_pc := epc_G/epc_total]
  
  dt[, epc_A_imp := epc_A_pc * nElecMeters] # rebase using nElecMeters
  dt[, epc_B_imp := epc_B_pc * nElecMeters]
  dt[, epc_C_imp := epc_C_pc * nElecMeters]
  dt[, epc_D_imp := epc_D_pc * nElecMeters]
  dt[, epc_E_imp := epc_E_pc * nElecMeters]
  dt[, epc_F_imp := epc_F_pc * nElecMeters]
  dt[, epc_G_imp := epc_G_pc * nElecMeters]
  
  return(dt)
}


selectedLsoasDT <- impute_epcs(selectedLsoasDT)

selected_epc_st <- selectedLsoasDT[, .(nDwellings_A = sum(epc_A_imp),
                          nDwellings_B = sum(epc_B_imp),
                          nDwellings_C = sum(epc_C_imp),
                          nDwellings_D = sum(epc_D_imp),
                          nDwellings_E = sum(epc_E_imp),
                          nDwellings_F = sum(epc_F),
                          nDwellings_G = sum(epc_G_imp)), keyby = .(IndDec)]
selected_epc_st_m <- melt(selected_epc_st, id.vars = "IndDec")
selected_epc_st_m <- selected_epc_st_m[, .(nDwellings = sum(value)), keyby = .(variable)]
selected_epc_st_m[, pc := 100*(nDwellings/sum(nDwellings))]
sum(selected_epc_st_m$pc)

mergedLSOA_Data_Eng <- impute_epcs(mergedLSOA_Data_Eng)
all_epc_st <- mergedLSOA_Data_Eng[, .(nDwellings_A = sum(epc_A_imp),
                          nDwellings_B = sum(epc_B_imp),
                          nDwellings_C = sum(epc_C_imp),
                          nDwellings_D = sum(epc_D_imp),
                          nDwellings_E = sum(epc_E_imp),
                          nDwellings_F = sum(epc_F),
                          nDwellings_G = sum(epc_G_imp)), keyby = .(IndDec)]
all_epc_st_m <- melt(all_epc_st, id.vars = "IndDec")
all_epc_st_m <- all_epc_st_m[, .(nDwellings = sum(value, na.rm = TRUE)), keyby = .(variable)]
all_epc_st_m[, pc := 100*(nDwellings/sum(nDwellings))]
sum(all_epc_st_m$pc)

compare <- selected_epc_st_m[all_epc_st_m]

ft <- flextable::flextable(compare)
colformat_double(ft, digits = 2)
```

Correlation between high % EPC F/G or A/B and deprivation?

```{r plotEPC_pc}
ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, y = epc_F_pc + epc_G_pc)) +
  geom_point() +
  geom_smooth()

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, y = epc_A_pc + epc_B_pc)) +
  geom_point() +
  geom_smooth()
```

Now we need to convert the % to dwellings using the number of electricity meters (see above).

```{r plotEPC_impute}
ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, y = epc_F_imp + epc_G_imp)) +
  geom_point() +
  geom_smooth()

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, y = epc_A_imp + epc_B_imp)) +
  geom_point() +
  geom_smooth()
```

### Estimate costs - sheep dip D to G

Upgrade all D-G

```{r estRetrofitCosts}

fromAE <- 13300
fromFG <- 26800
selectedLsoasDT[, retrofitDE_cost := (epc_D_imp + epc_E_imp) * fromAE] # exclude epc_A_imp
selectedLsoasDT[, retrofitFG_cost := (epc_F_imp + epc_G_imp) * fromFG]
selectedLsoasDT[, sumDE := (epc_D_imp + epc_E_imp)]
selectedLsoasDT[, sumFG := (epc_F_imp + epc_G_imp)]

selectedLsoasDT[, retrofitSum := retrofitDE_cost + retrofitFG_cost]
selectedLsoasDT[, retrofitMeanPerDw := retrofitSum/(epc_D_imp + epc_E_imp + epc_F_imp + epc_G_imp)] # might create an NA if 
```

Table \@ref(tab:reportRetrofitCosts) reports total retofit costs.

```{r reportRetrofitCosts}
mil <- 1000000
message("To retrofit D-E (£m)")
sum(selectedLsoasDT$retrofitDE_cost)/mil
message("Number of dwellings: ", round(sum(selectedLsoasDT$sumDE)))

message("To retrofit F-G (£m)")
sum(selectedLsoasDT$retrofitFG_cost)/mil
message("Number of dwellings: ", round(sum(selectedLsoasDT$sumFG)))

message("To retrofit D-G (£m)")
sum(selectedLsoasDT$retrofitSum)/mil

message("To retrofit D-G (mean per dwelling)")
mean(selectedLsoasDT$retrofitMeanPerDw, na.rm = TRUE)

t <- selectedLsoasDT[, .(meanPerLSOA_GBPm = mean(retrofitSum)/mil,
                total_GBPm = sum(retrofitSum)/mil)]

makeFlexTable(t, cap = paste0("Retrofit cost totals (£m GBP): ", rParams$filter))
```

```{r plotRetrofitCosts}
ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, y = retrofitSum/1000000)) +
  geom_point(aes(colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Total retrofit cost (£M)",
       caption = capFilter)
#ggplot2::ggsave(filename = here::here("plots", "allLSOAs_retrofitSum.png"))

ggplot2::ggplot(selectedLsoasDT, aes(x = IMD_Decile_label, 
                            y = retrofitSum/1000000,
                            colour = IMD_Decile_label)) +
  geom_boxplot() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Total retrofit cost (£M)",
       caption = capFilter)

ggplot2::ggplot(selectedLsoasDT, aes(x = IMD_Decile_label, y = retrofitMeanPerDw)) +
  geom_boxplot() +
  labs(y = "Mean retrofit cost per dwelling (£)",
       caption = capFilter)
```
Figure \@ref(fig:plotRetrofitCostsPerDwelling) shows the LSOA level retofit costs per dwelling by IMD decile.

```{r plotRetrofitCostsPerDwelling, fig.cap="LSOA level retofit costs per dwelling by IMD score"}
ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, y = retrofitMeanPerDw)) +
  geom_point(aes(colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Mean retrofit cost per dwelling (£)",
       caption = capFilter)
#ggplot2::ggsave(filename = here::here("plots", "allLSOAs_retrofit_per_dwelling.png"))
```

```{r costsBySocialRent}

selectedLsoasDT[, c2011_pc_social_rent_decile := cut(c2011_pc_social_rent, 
                                                   breaks = quantile(c2011_pc_social_rent, probs = 0:10/10),
                                                   labels = 1:10, right = FALSE)]
epc_compare <- selectedLsoasDT[, .(Cost_DE = sum(retrofitDE_cost, na.rm = TRUE),
                                   Cost_FG = sum(retrofitFG_cost, na.rm = TRUE)), 
                                   keyby = .(c2011_pc_social_rent_decile)]
plotDT <- melt(epc_compare, id.vars = c("c2011_pc_social_rent_decile"))

ggplot2::ggplot(plotDT[!is.na(c2011_pc_social_rent_decile)], aes(x =  c2011_pc_social_rent_decile, y = value, fill = variable )) +
  geom_col(position = "stack") +
  scale_fill_viridis_d(name = "EPC Band", direction = -1) +
  labs(y = "£",
       x = "% social rent decile")

```

```{r costsByPrivateRent}

selectedLsoasDT[, c2011_pc_private_rent_decile := cut(c2011_pc_private_rent, 
                                                   breaks = quantile(c2011_pc_private_rent, probs = 0:10/10),
                                                   labels = 1:10, right = FALSE)]
epc_compare <- selectedLsoasDT[, .(Cost_DE = sum(retrofitDE_cost, na.rm = TRUE),
                                   Cost_FG = sum(retrofitFG_cost, na.rm = TRUE)), 
                                   keyby = .(c2011_pc_private_rent_decile)]
plotDT <- melt(epc_compare, id.vars = c("c2011_pc_private_rent_decile"))

ggplot2::ggplot(plotDT[!is.na(c2011_pc_private_rent_decile)], aes(x =  c2011_pc_private_rent_decile, y = value, fill = variable )) +
  geom_col(position = "stack") +
  scale_fill_viridis_d(name = "EPC Band", direction = -1) +
  labs(y = "£",
       x = "% private rent decile")

```

```{r costsByIMD}


epc_compare <- selectedLsoasDT[, .("D-E" = sum(retrofitDE_cost, na.rm = TRUE),
                                   "F-G" = sum(retrofitFG_cost, na.rm = TRUE)), 
                                   keyby = .(IMD_Decile_label)]
plotDT <- melt(epc_compare, id.vars = c("IMD_Decile_label"))

ggplot2::ggplot(plotDT[!is.na(IMD_Decile_label)], aes(x =  IMD_Decile_label, y = value/1000000, fill = variable )) +
  geom_col(position = "stack") +
  scale_fill_viridis_d(name = "EPC Band", direction = -1) +
  labs(y = "£ retrofit cost (£m)",
       x = "IMD decile")

ggplot2::ggsave(paste0(rmdParams$plotPath, "BC_r1_Figure_5.jpg"))

```

### Estimate costs - sheep dip D to G but upgrades in 20% poorest areas funded by HM Gov (somehow)

Set aside areas in IMD decile 1 & 2? Assume costs met by HM Treasury or elsewhere e.g. energy levy etc

> to do

## Compare levy with costs

### Scenario 1

Totals

```{r co2eToRettofitTotalScenario1, fig.height=5}
ggplot2::ggplot(selectedLsoasDT, aes(x = beis_GBPtotal_c/1000, y = retrofitSum/1000)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Total estimated levy (all emissions, £k)",
       y = "Dwelling retrofit cost (£k)",
       caption = capFilter)

#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWins_RetrofitCost_beis_GBPtotal_sc1.png"))

ggplot2::ggplot(selectedLsoasDT, aes(x = (beis_GBPtotal_c_gas + beis_GBPtotal_c_elec)/1000, y = retrofitSum/1000)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Total estimated levy (energy, £k)",
       y = "Dwelling retrofit cost (£k)",
       caption = capFilter)

#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWins_RetrofitCost_beis_GBPtotal_sc1_energy.png"))
```

Repeat per dwelling

```{r co2eToRettofitPerDwellingScenario1, fig.height=5}
ggplot2::ggplot(selectedLsoasDT, 
                aes(x = beis_GBPtotal_c_perdw, y = retrofitMeanPerDw)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Mean emissions levy (all emissions, £)",
       y = "Mean dwelling retrofit cost (£)",
       caption = capFilter)
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWins_RetrofitCost_beis_GBPtotal_sc1_perdw.png"))

ggplot2::ggplot(selectedLsoasDT, aes(x = (beis_GBPtotal_c_gas_perdw + beis_GBPtotal_c_elec_perdw), y = retrofitMeanPerDw)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Mean emissions levy per dwelling due to energy (£)",
       y = "Mean dwelling retrofit cost (£k)",
       caption = capFilter)

#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWins_RetrofitCost_beis_GBPtotal_energy_sc1_perdw.png"))
```

### Scenario 2

Totals

```{r co2eToRettofitTotalScenario2, fig.height=5}
ggplot2::ggplot(selectedLsoasDT, aes(x = beis_GBPtotal_sc2/1000, y = retrofitSum/1000)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Total estimated levy (all emissions, £k)",
       y = "Dwelling retrofit cost (£k)",
       caption = capFilter)

#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWins_RetrofitCost_beis_GBPtotal_sc2.png"))

ggplot2::ggplot(selectedLsoasDT, aes(x = (beis_GBPtotal_c_gas + beis_GBPtotal_c_elec)/1000, y = retrofitSum/1000)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Total estimated levy (energy, £k)",
       y = "Dwelling retrofit cost (£k)",
       caption = capFilter)

#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWins_RetrofitCost_beis_GBPtotal_c_energy.png"))
```

Repeat per dwelling

```{r co2eToRettofitPerDwellingScenario2, fig.height=5}
ggplot2::ggplot(selectedLsoasDT, 
                aes(x = beis_GBPtotal_c_perdw, y = retrofitMeanPerDw)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Mean emissions levy (all emissions, £)",
       y = "Mean dwelling retrofit cost (£)",
       caption = capFilter)
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWins_RetrofitCost_beis_GBPtotal_c_perdw.png"))

ggplot2::ggplot(selectedLsoasDT, aes(x = (beis_GBPtotal_c_gas_perdw + beis_GBPtotal_c_elec_perdw), y = retrofitMeanPerDw)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Mean emissions levy per dwelling due to energy (£)",
       y = "Mean dwelling retrofit cost (£k)",
       caption = capFilter)

#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWins_RetrofitCost_beis_GBPtotal_c_energy_perdw.png"))
```

## Years to pay...

### Scenario 1

Figure \@ref(fig:allLevyPayOffSc1) shows years to pay under Scenario 1 (all emissions)

```{r allLevyPayOffSc1, fig.height=5, fig.cap="Years to pay under Scenario 1 (all em issions)"}

selectedLsoasDT[, yearsRequiredToPayRetrofit_beis_GBPtotal_c_perdw := retrofitMeanPerDw/beis_GBPtotal_c_perdw]
summary(selectedLsoasDT$yearsRequiredToPayRetrofit_beis_GBPtotal_c_perdw)

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, 
                            y = yearsRequiredToPayRetrofit_beis_GBPtotal_c_perdw)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  geom_hline(yintercept = median(selectedLsoasDT$yearsRequiredToPayRetrofit_beis_GBPtotal_c_perdw), colour = "orange") +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Years to pay off",
       caption = paste0("BEIS central carbon cost, all emissions levy", "\n", capFilter))
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWins_yearsRequiredToPayRetrofit_beis_GBPtotal_sc1_perdw.png"))
ggplot2::ggsave(paste0(rmdParams$plotPath, "BC_r1_Figure_8.jpg"))

m <- median(selectedLsoasDT$yearsRequiredToPayRetrofit_beis_GBPtotal_c_perdw)
message("Median years: ", round(m,2))
```

Figure \@ref(fig:energyLevyPayOffSc1) shows years to pay under Scenario 1 (energy emissions)

```{r energyLevyPayOffSc1, fig.height=5, fig.cap="Years to pay under Scenario 1 (energy emissions)"}
selectedLsoasDT[, yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw := retrofitMeanPerDw/(beis_GBPtotal_c_gas_perdw + beis_GBPtotal_c_elec_perdw)]

summary(selectedLsoasDT$yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw)

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, 
                            y = yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  geom_hline(yintercept = median(selectedLsoasDT$yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw), colour = "orange") +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Years to pay off",
       caption = paste0("BEIS central carbon cost, gas emissions levy\n(excludes LSOA with 0 gas)\n", capFilter))
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWins_yearsRequiredToPayRetrofit_beis_GBPtotal_energy_sc1_perdw.png"))
m <- median(selectedLsoasDT$yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw)
message("Median years: ", round(m,2))
```

Figure \@ref(fig:transferVisAllSc1) shows the year 1 outcome if levy is shared equally (all emissions levy).

```{r transferVisAllSc1, fig.cap="Year 1 outcome if levy is shared equally (all emissions levy)"}
plotDT <- selectedLsoasDT[, .(LSOA11CD, beis_GBPtotal_c, beis_GBPtotal_c_elec, beis_GBPtotal_c_gas, retrofitSum, WD18NM, IMD_Decile_label, IMDScore)]
share_Y1_total_c <- sum(plotDT$beis_GBPtotal_c)/uniqueN(plotDT$LSOA11CD) # divide the year 1 levy equally
share_Y1_energy_c <- (sum(plotDT$beis_GBPtotal_c_elec) + sum(plotDT$beis_GBPtotal_c_gas))/uniqueN(plotDT$LSOA11CD) # divide the year 1 levy equally


plotDT[, surplusY1_total_c := share_Y1_total_c - retrofitSum] # equal share

plotDT[, surplusY1_energy_c := share_Y1_energy_c - retrofitSum]

# Breaks if doing all England!!
ggplot2::ggplot(plotDT, aes(x = reorder(LSOA11CD, -retrofitSum), fill = retrofitSum/1000000)) +
  geom_col(aes(y = retrofitSum/1000000)) +
  geom_point(aes(y = share_Y1_total_c/1000000, colour = "Levy Year 1")) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  scale_fill_continuous(name = "Retrofit cost (£M)") +
  scale_color_discrete(name = "Levy Year 1 (£M)") +
  facet_wrap(. ~ WD18NM, scales="free_x") +
  labs(x = "LSOAs (ordered by retrofit cost)",
       y = "£M",
       caption = "BEIS central carbon cost, all emissions levy")
# 
ggplot2::ggsave(paste0(rmdParams$plotPath, "BC_r1_Figure_9.jpg"))

# #ggplot2::ggsave(filename = here::here("plots/allLSOAs_transferVis_allEmissions_sc1.png"))

ggplot2::ggplot(plotDT, aes(x = reorder(LSOA11CD, -retrofitSum), colour = IMD_Decile_label,
                            y = surplusY1_total_c/1000000)) +
                  geom_point() +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  geom_hline(yintercept = 0, colour = "red") +
  scale_color_discrete(name = "IMD Score decile") +
  labs(x = "LSOAs (ordered by retrofit cost)",
       y = "Year 1 surplus (£M)",
       caption = paste0("BEIS central carbon cost, all emissions levy", "\n", capFilter))

#ggplot2::ggsave(filename = here::here("plots/allLSOAs_surplusVis_allEmissions_sc1.png"))

t <- head(selectedLsoasDT[, .(LSOA11CD,LSOA11NM, WD18NM, retrofitSum,yearsToPay = yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw, epc_D_pc, epc_E_pc, epc_F_pc, epc_G_pc)][order(-retrofitSum)],10)

makeFlexTable(t, cap = "Highest retofit sum cost under Scenario 1")
```

Figure \@ref(fig:transferVisEnergSc1y) shows the year 1 outcome if levy is shared equally (energy emissions levy).

```{r transferVisEnergSc1y, fig.cap="Year 1 outcome if levy is shared equally (energy emissions levy)"}


ggplot2::ggplot(plotDT, aes(x = reorder(LSOA11CD, -retrofitSum), colour = IMD_Decile_label,
                            y = surplusY1_energy_c/1000000)) +
                  geom_point() +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  geom_hline(yintercept = 0, colour = "red") +
  scale_color_discrete(name = "IMD decile") +
  labs(x = "LSOAs (ordered by retrofit cost)",
       y = "Year 1 surplus (£M)",
       caption = paste0("BEIS central carbon cost, energy emissions levy", "\n", capFilter))
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_surplusVis_energyEmissions_sc1.png"))


```

What happens in Year 2 totally depends on the rate of upgrades... given the supply chain & capacity issues it's likely that the levy would build up a substantial 'headroom' that could then be spent over time...

### Scenario 2

Figure \@ref(fig:allLevyPayOffSc2) shows years to pay under Scenario 2 (all emissions)

```{r allLevyPayOffSc2, fig.height=5, fig.cap="Years to pay under Scenario 2 (all em issions)"}

selectedLsoasDT[, yearsRequiredToPayRetrofit_beis_GBPtotal_sc2_perdw := retrofitMeanPerDw/beis_GBPtotal_sc2_perdw]
summary(selectedLsoasDT$yearsRequiredToPayRetrofit_beis_GBPtotal_sc2_perdw)

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, 
                            y = yearsRequiredToPayRetrofit_beis_GBPtotal_sc2_perdw)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  geom_hline(yintercept = median(selectedLsoasDT$yearsRequiredToPayRetrofit_beis_GBPtotal_sc2_perdw), colour = "orange") +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Years to pay off",
       caption = paste0("Rising block, all emissions levy",
                        "\n", capFilter))
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWins_yearsRequiredToPayRetrofit_beis_GBPtotal_sc2_perdw.png"))
m <- median(selectedLsoasDT$yearsRequiredToPayRetrofit_beis_GBPtotal_sc2_perdw)
message("Median years: ", round(m,2))
```

Figure \@ref(fig:energyLevyPayOffSc2) shows years to pay under Scenario 2 (energy emissions)

```{r energyLevyPayOffSc2, fig.height=5, fig.cap="Years to pay under Scenario 2 (energy emissions)"}
selectedLsoasDT[, yearsRequiredToPayRetrofit_beis_GBPtotal_sc2_energy_perdw := retrofitMeanPerDw/(beis_GBPgas_sc2_perdw + beis_GBPelec_sc2_perdw)]

summary(selectedLsoasDT$yearsRequiredToPayRetrofit_beis_GBPtotal_c_energy_perdw)

ggplot2::ggplot(selectedLsoasDT, aes(x = IMDScore, 
                            y = yearsRequiredToPayRetrofit_beis_GBPtotal_sc2_energy_perdw)) +
  geom_point(aes(size = CREDS_pc_Heating_Electric_2011, colour = IMD_Decile_label)) +
  geom_smooth() +
  geom_hline(yintercept = median(selectedLsoasDT$yearsRequiredToPayRetrofit_beis_GBPtotal_sc2_energy_perdw), colour = "orange") +
  scale_size_continuous(name = "% Electric heating") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(y = "Years to pay off",
       caption = paste0("Rising block, all emissions levy",
                        "\nEcludes LSOAs with 0 gas",
                        "\n",capFilter))
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_whoWins_yearsRequiredToPayRetrofit_beis_GBPtotal_energy_sc2_perdw.png"))

```

Figure \@ref(fig:transferVisAllSc2) shows the year 1 outcome if levy is shared equally (all emissions levy).

```{r transferVisAllSc2, fig.cap="Year 1 outcome if levy is shared equally (all emissions levy)"}
plotDT <- selectedLsoasDT[, .(LSOA11CD, beis_GBPtotal_sc2, beis_GBPelec_sc2, beis_GBPgas_sc2, retrofitSum, WD18NM, IMDScore, IMD_Decile_label)]
share_Y1_total_sc2 <- sum(plotDT$beis_GBPtotal_sc2)/uniqueN(plotDT$LSOA11CD) # divide the year 1 levy equally
share_Y1_energy_sc2 <- (sum(plotDT$beis_GBPelec_sc2) + sum(plotDT$beis_GBPgas_sc2))/uniqueN(plotDT$LSOA11CD) # divide the year 1 levy equally


plotDT[, surplusY1_total_sc2 := share_Y1_total_sc2 - retrofitSum] # equal share

plotDT[, surplusY1_energy_sc2 := share_Y1_energy_sc2 - retrofitSum]


ggplot2::ggplot(plotDT, aes(x = reorder(LSOA11CD, -retrofitSum), colour = IMD_Decile_label,
                            y = surplusY1_total_sc2/1000000)) +
                  geom_point() +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  geom_hline(yintercept = 0, colour = "red") +
  scale_color_discrete(name = "IMD decile") +
  labs(x = "LSOAs (ordered by retrofit cost)",
       y = "Year 1 surplus (£M)",
       caption = paste0("Rising block, all emissions levy",
                        "\n", capFilter))
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_surplusVis_allEmissions_sc2.png"))

```

Figure \@ref(fig:transferVisEnergySc2) shows the year 1 outcome if levy is shared equally (energy emissions levy).

```{r transferVisEnergySc2, fig.cap="Year 1 outcome if levy is shared equally (energy emissions levy)"}
ggplot2::ggplot(plotDT, aes(x = reorder(LSOA11CD, -retrofitSum), colour = IMD_Decile_label,
                            y = surplusY1_energy_sc2/1000000)) +
                  geom_point() +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  geom_hline(yintercept = 0, colour = "red") +
  scale_color_discrete(name = "IMD decile") +
  labs(x = "LSOAs (ordered by retrofit cost)",
       y = "Year 1 surplus (£M)",
       caption = paste0("Rising block, energy emissions levy",
                        "\n", capFilter))
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_surplusVis_energyEmissions_sc2.png"))


```

What happens in Year 2 totally depends on the rate of upgrades...

#### Compare scenarios

Figure \@ref(fig:comparePayBack) compares pay-back times for the two scenarios - who does the rising block tariff help?

```{r comparePayBack, fig.height=5, fig.cap="Comparing pay-back times across scenarios"}

ggplot2::ggplot(selectedLsoasDT, aes(x = yearsRequiredToPayRetrofit_beis_GBPtotal_c_perdw, 
                            y = yearsRequiredToPayRetrofit_beis_GBPtotal_sc2_perdw)) +
  geom_abline(slope = 1, intercept = 0) +
  geom_point(aes(size = CREDS_total_kgco2e_pdw/1000, colour = IMD_Decile_label)) +
  scale_size_continuous(name = "T CO2e/annum/dwelling") +
  scale_color_viridis_d(name = "IMD Decile") +
  labs(x = "Years to pay: Scenario 1",
       y = "Years to pay: Scenario 2",
       caption = paste0("Comparing scenarios, all emissions levy",
                        "\n", capFilter, ", x = y line plotted for clarity"))
#ggplot2::ggsave(filename = here::here("plots/allLSOAs_compare_whoWins_yearsRequiredToPayRetrofit_beis_GBPtotal_perdw.png"))

ggplot2::ggsave(paste0(rmdParams$plotPath, "BC_r1_Figure_11.jpg"))


```

# Area level study context

Do this heare so all estimations & imputations have been done.

This report focuses on `r rParams$filter`.

Observed EPCs - need to check bias wrt e.g. Census data. EPCs more likely to be from new houses, rentals, re-sales (required) etc.

 * EPC: "type_house_semi"               "type_house_midterrace"  "type_house_endterrace"         "type_house_detached"           "type_flat"                     "type_maisonette"

 * Census: semi, terrace, detached, flat, maisonette

```{r caseStudyContext_obsEPC}

mergedLSOA_Data_Eng <- impute_epcs(mergedLSOA_Data_Eng)
# compare EPC
epc_compare <- mergedLSOA_Data_Eng[, .(A = sum(epc_A, na.rm = TRUE),
                                       B = sum(epc_B, na.rm = TRUE),
                                       C = sum(epc_C, na.rm = TRUE),
                                       D = sum(epc_D, na.rm = TRUE),
                                       E = sum(epc_E, na.rm = TRUE),
                                       F = sum(epc_F, na.rm = TRUE),
                                       G = sum(epc_G, na.rm = TRUE)), 
                                   keyby = .(case_study, IMD_Decile_label)]
plotDT <- melt(epc_compare, id.vars = c("IMD_Decile_label", "case_study"))
plotDT[case_study == 0, case_study_label := "Rest of England"]
plotDT[case_study == 1, case_study_label := rmdParams$filter]
ggplot2::ggplot(plotDT, aes(x =  IMD_Decile_label, y = value, fill = variable )) +
  geom_col(position = "stack") +
  facet_grid(case_study_label ~ ., scales = "free_y") +
  scale_fill_viridis_d(name = "EPC Band", direction = -1) +
  labs(y = "Number of dwellings",
       x = "IMD decile")

ggplot2::ggsave(paste0(rmdParams$plotPath, "BC_r1_Figure_2.jpg"))

```

Imputed EPCs - this corrects for numbers but not the bias in the EPC sample

```{r caseStudyContext_impEPC}

epc_compare_imp <- mergedLSOA_Data_Eng[, .(nDwellings_A = sum(epc_A_imp, na.rm = TRUE),
                                       nDwellings_B = sum(epc_B_imp, na.rm = TRUE),
                                       nDwellings_C = sum(epc_C_imp, na.rm = TRUE),
                                       nDwellings_D = sum(epc_D_imp, na.rm = TRUE),
                                       nDwellings_E = sum(epc_E_imp, na.rm = TRUE),
                                       nDwellings_F = sum(epc_F_imp, na.rm = TRUE),
                                       nDwellings_G = sum(epc_G_imp, na.rm = TRUE)), keyby = .(case_study, IMD_Decile_label)]
plotDT <- melt(epc_compare_imp, id.vars = c("IMD_Decile_label", "case_study"))
plotDT[case_study == 0, case_study_label := "Rest of England"]
plotDT[case_study == 1, case_study_label := rmdParams$filter]
ggplot2::ggplot(plotDT, aes(x =  IMD_Decile_label, y = value, fill = variable )) +
  geom_col(position = "stack") +
  facet_grid(case_study_label ~ ., scales = "free_y") +
  scale_fill_viridis_d(name = "EPC Band", direction = -1) +
  labs(y = "Number of dwellings",
       x = "IMD decile")

```

```{r caseStudyContext_income}
# compare income
mergedLSOA_Data_Eng[, .(mean_MSOA_totInc = mean(msoa_tot_annual_income_2018)), keyby = .(case_study)]

# compare EPC for income
mergedLSOA_Data_Eng[, mean_MSOA_totInc_decile := cut(msoa_tot_annual_income_2018, 
                                                   breaks = quantile(msoa_tot_annual_income_2018, probs = 0:10/10),
                                                   labels = 1:10, right = FALSE)]
epc_compare <- mergedLSOA_Data_Eng[, .(A = sum(epc_A, na.rm = TRUE),
                                       B = sum(epc_B, na.rm = TRUE),
                                       C = sum(epc_C, na.rm = TRUE),
                                       D = sum(epc_D, na.rm = TRUE),
                                       E = sum(epc_E, na.rm = TRUE),
                                       F = sum(epc_F, na.rm = TRUE),
                                       G = sum(epc_G, na.rm = TRUE)), 
                                   keyby = .(case_study, mean_MSOA_totInc_decile)]

plotDT <- melt(epc_compare, id.vars = c("mean_MSOA_totInc_decile", "case_study"))
plotDT[case_study == 0, case_study_label := "Rest of England"]
plotDT[case_study == 1, case_study_label := rmdParams$filter]

ggplot2::ggplot(plotDT[!is.na(mean_MSOA_totInc_decile)], aes(x =  mean_MSOA_totInc_decile, y = value, fill = variable )) +
  geom_col(position = "stack") +
  facet_grid(case_study_label ~ ., scales = "free_y") +
  scale_fill_viridis_d(name = "EPC Band", direction = -1) +
  labs(y = "Number of dwellings",
       x = "Income decile")


```

```{r caseStudyContext_renters}
# social & private renters
mergedLSOA_Data_Eng[, c2011_pc_social_rent_decile := cut(c2011_pc_social_rent, 
                                                   breaks = quantile(c2011_pc_social_rent, probs = 0:10/10),
                                                   labels = 1:10, right = FALSE)]
epc_compare <- mergedLSOA_Data_Eng[, .(A = sum(epc_A, na.rm = TRUE),
                                       B = sum(epc_B, na.rm = TRUE),
                                       C = sum(epc_C, na.rm = TRUE),
                                       D = sum(epc_D, na.rm = TRUE),
                                       E = sum(epc_E, na.rm = TRUE),
                                       F = sum(epc_F, na.rm = TRUE),
                                       G = sum(epc_G, na.rm = TRUE)), 
                                   keyby = .(case_study, c2011_pc_social_rent_decile)]
plotDT <- melt(epc_compare, id.vars = c("c2011_pc_social_rent_decile", "case_study"))
plotDT[case_study == 0, case_study_label := "Rest of England"]
plotDT[case_study == 1, case_study_label := rmdParams$filter]

ggplot2::ggplot(plotDT[!is.na(c2011_pc_social_rent_decile)], aes(x =  c2011_pc_social_rent_decile, y = value, fill = variable )) +
  geom_col(position = "stack") +
  facet_grid(case_study_label ~ ., scales = "free_y") +
  scale_fill_viridis_d(name = "EPC Band", direction = -1) +
  labs(y = "Number of dwellings",
       x = "% social rent decile")

ggplot2::ggsave(paste0(rmdParams$plotPath, "BC_r1_Figure_3.jpg"))


mergedLSOA_Data_Eng[, c2011_pc_private_rent_decile := cut(c2011_pc_private_rent, 
                                                   breaks = quantile(c2011_pc_private_rent, probs = 0:10/10),
                                                   labels = 1:10, right = FALSE)]
epc_compare <- mergedLSOA_Data_Eng[, .(A = sum(epc_A, na.rm = TRUE),
                                       B = sum(epc_B, na.rm = TRUE),
                                       C = sum(epc_C, na.rm = TRUE),
                                       D = sum(epc_D, na.rm = TRUE),
                                       E = sum(epc_E, na.rm = TRUE),
                                       F = sum(epc_F, na.rm = TRUE),
                                       G = sum(epc_G, na.rm = TRUE)), 
                                   keyby = .(case_study, c2011_pc_private_rent_decile)]
plotDT <- melt(epc_compare, id.vars = c("c2011_pc_private_rent_decile", "case_study"))
plotDT[case_study == 0, case_study_label := "Rest of England"]
plotDT[case_study == 1, case_study_label := rmdParams$filter]

ggplot2::ggplot(plotDT[!is.na(c2011_pc_private_rent_decile)], aes(x =  c2011_pc_private_rent_decile, y = value, fill = variable )) +
  geom_col(position = "stack") +
  facet_grid(case_study_label ~ ., scales = "free_y") +
  scale_fill_viridis_d(name = "EPC Band", direction = -1) +
  labs(y = "Number of dwellings",
       x = "% private rent decile")

ggplot2::ggsave(paste0(rmdParams$plotPath, "BC_r1_Figure_4.jpg"))

```


# R environment

## R packages used

* base R [@baseR]
* bookdown [@bookdown]
* data.table [@data.table]
* ggplot2 [@ggplot2]
* kableExtra [@kableExtra]
* knitr [@knitr]
* rmarkdown [@rmarkdown]
* skimr [@skimr]

## Session info


# Data Tables

I don't know if this will work...

```{r skimTables}
# tables <- names(data)
# for(t in tables){
#   print(lapply(tables, FUN(x) skimr::skim(data$eval(t)))
# }
message("Doesn't")
```

# References

